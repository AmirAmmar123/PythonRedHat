Chapter 4.  Functions

Functions
Summary

Abstract

Goal 	

Encapsulate code in small and reusable logic blocks.
Objectives 	

    Define and use custom functions within a Python program.

    Define functions that allow passing of named and optional arguments.

    Define and use functions that allow a variable number of arguments.

    Understand access the various scopes of variables within a Python application.

    Pass references to functions the same way references to other objects are used.

    Use the map and filter datatypes to apply a function to iterable objects.

    Understand and use nested functions and lambdas.

    Define and use recursive functions.

Sections 	

    Functions

Functions
Objectives

    Define and use custom functions within a Python program.

    Define functions that allow passing of named and optional arguments.

    Define and use functions that allow a variable number of arguments.

    Understand access the various scopes of variables within a Python application.

    Pass references to functions the same way references to other objects are used.

    Use the map and filter datatypes to apply a function to iterable objects.

    Understand and use nested functions and lambdas.

    Define and use recursive functions.

Introduction

Large programs are more easily understood, maintained, and debugged if they are divided into manageable reusable pieces.

One way to do this is by using functions.

    A function represents a body of code that can be written once and then executed whenever the need arises, possibly multiple times.

    The function might be encoded in the program that needs it, or it may be located in a separate file and used by any program(s) that needs it.

Functions can also be grouped together into a library and reused over a series of applications by the entire enterprise.

    Libraries in Python are called modules.

    Modules will be discussed in more detail in he next chapter.

We have already seen many functions that are part of the standard Python library.

Here are just some of the functions that have been used.
input() 	oct() 	str()
print() 	bin() 	sorted()
len() 	int() 	type()
hex() 	float() 	 

However, you can always write your own custom functions, and this chapter explores the details of doing that.

Defining Your Own Functions

The keyword def creates a function.

    Following that keyword is the name of the function and a set of parenthesis, followed by a colon.

    Define parameters inside the parenthesis if necessary.

The following example is a simple function that takes some text as a parameter and displays it with a border in the output.

    The definition of a function must precede its invocation.

first_function.py

#!/usr/bin/env python3
def print_with_border(some_text):
    border = len(some_text) * "#"
    print(border)
    print(some_text)
    print(border)


print_with_border("Hello")
print_with_border("Goodbye")
data = input("Enter some text: ")
print_with_border(data)

$ python3 first_function.py
#####
Hello
#####
#######
Goodbye
#######
Enter some text: Functions are very powerful
###########################
Functions are very powerful
###########################
$

Parameters and Arguments

In general, functions are more useful when you can pass data to them and have the function operate on the data.

    The function definition declares the parameters you can pass to it.

    Pass arguments in the function call for the function to use in the place of each parameter.

        Each argument that is sent to the function must have a corresponding parameter defined in the header part of the function.

        The arguments are passed by reference to the function, which is an important aspect of an object-oriented language.

    Optionally, a function may return a value using the return keyword.

        If no return is specified, a function returns a reference to the None object, by default.

In the previous example, the print_with_border function defines a single parameter named some_text.

    The example below modifies the previous function to build a string and return it to the caller as opposed to printing it.

    Ultimately the result is the same as the previous, but now it is the caller of the function that decides to print the result.

second_function.py

#!/usr/bin/env python3
def wrap_with_border(some_text):
    result = [len(some_text) * "#"]
    result.append(some_text)
    result.append(result[0])
    return "\n".join(result)


data = wrap_with_border("Hello")
print(data)
print(wrap_with_border("Goodbye"))

Function Documentation

To document a function, define a literal string as the first statement within the body of the function.

    The interpreter accepts everything in this string as documentation.

    Accessing the documentation string is then available to programmers through Python's help() function or through a special property of the function object named __doc__.

help(function_name)
print(function_name.__doc__)

Notice the output from the following program.

third_function.py

#!/usr/bin/env python3
def wrap_with_border(some_text):
    """ Returns a string of some_text with a line of # signs
        before and after it"""
    result = [len(some_text) * "#"]
    result.append(some_text)
    result.append(result[0])
    return "\n".join(result)


print("The doc string is:\n", wrap_with_border.__doc__)

The output of the above program is shown next.

$ python3 third_function.py
The doc string is:
  Returns a string of some_text with a line of # signs
        before and after it
$

References

More information about docstring conventions can be found in PEP 257 at the following URL https://www.python.org/dev/peps/pep-0257/

Named Arguments

Python provides several ways to pass arguments to functions.

    You can always pass the arguments in the traditional way.

traditional_args.py

#!/usr/bin/env python3
def volume(length, width, height):
    """Returns the volume of a box for given dimensions"""
    return length * width * height


dim1 = float(input("Enter length of the box: "))
dim2 = float(input("Enter width of the box: "))
dim3 = float(input("Enter height of the box: "))
result = volume(dim1, dim2, dim3)
print("The volume is:", result)

    Python also allows passing named arguments to a function, where the name of the argument matches the name of a parameter of the defined function.

    An advantage of the named argument approach is that the arguments can be passed in any order as shown in the next example.

    Named arguments make calling the function easier to read.

    Another advantage is that the named arguments make the purpose of each argument clear.

named_args.py

#!/usr/bin/env python3
def volume(length, width, height):
    """Returns the volume of a box for given dimensions"""
    return length * width * height


dim1 = float(input("Enter length of the box: "))
dim2 = float(input("Enter width of the box: "))
dim3 = float(input("Enter height of the box: "))
result = volume(length=dim1, width=dim2, height=dim3)
print("The volume is:", result)

result = volume(height=dim3, length=dim1, width=dim2)
print("The volume is:", result)

Optional Arguments

A function can also define default values for parameters.

    When a parameter is defined with a default value, it makes the passing of the value for it as an argument optional as shown next.

optional_args.py

#!/usr/bin/env python3
def volume(length=10, width=5, height=2):
    """Returns the volume of a box for given dimensions"""
    return length * width * height


print("1:", volume(2, 3, 4))
print("2:", volume(2, 3))
print("3:", volume(2))
print("4:", volume())

vol = volume(30, height=4, width=20)
print("5:", vol)

print("6:", volume(height=3))
print("7:", volume(height=7, width=2))

$ python3 optional_args.py
1: 24
2: 12
3: 20
4: 100
5: 2400
6: 150
7: 140
$

Whenever positional arguments and named arguments are passed within the same function call, the named arguments must be to the right of all other positional arguments.

The following attempt at calling the volume would be invalid syntax:

volume(length=10, width=20, 30)

Passing Collections to a Function

Here is a function that takes a list as a parameter named a_list and updates the list by multiplying each of its elements by the qty parameter.

pass_list.py

#!/usr/bin/env python3
def multiply_by(qty, a_list):
    for index, value in enumerate(a_list):
        a_list[index] = value * qty


def process_list(a_list):
    print("Before:", a_list)
    multiply_by(5, a_list)
    print("After:", a_list)


data = [10, 20, 30, 40]
process_list(data)

data = ["Me", "the", "Hello"]
process_list(data)

The output of the above program is shown next.

$ python3 pass_list.py
Before: [10, 20, 30, 40]
After: [50, 100, 150, 200]
Before: ['Me', 'the', 'Hello']
After: ['MeMeMeMeMe', 'thethethethethe', 'HelloHelloHelloHelloHello']
$

In the example, the data variable stores each list.

    The first call to process_list(data) passes a copy of the object reference to the process_list function. The a_list variable is assigned to the reference while inside the body of the function.

    At this point in the program, there has only been one list created by the program, but two references (data and a_list) are referencing the single list of [10, 20, 30, 40].

The previous example worked with a lists that were composed of immutable objects (Strings and integers).

    The function extracts each element of the list and then updates the value, overwriting the previous value.

    The function uses the built-in enumerate() function to get the index of the value. The index is then used to write the result back into the same place.

for index, value in enumerate(a_list):
    a_list[index] = value * qty

The next example, passes a dictionary collection where each value in the dictionary is a list.

    The dictionary contains a collection of lists as its values.

    The goal is to add a new element to every list in the dictionary.

    The example demonstrates updating the value in a collection as opposed to replacing each element in a collection.

pass_dict.py

#!/usr/bin/env python3
def update_stickers(the_students, sticker):
    for stickers in the_students.values():
        stickers.append(sticker)


def print_students(students):
    for name, stickers in students.items():
        print("{:>8}:".format(name), " ".join(stickers))


students = {'declan': ["ü¶ã", "ü¶â", "ü¶Ç", "ü¶í"],
            'jill': ["ü¶Ü", "ü¶ì", "ü¶é", "ü¶Å"],
            'sam': ["ü¶ñ", "ü¶Ç", "ü¶ó"]}

print_students(students)
update_stickers(students, "ü¶à")
print("*" * 50)
print_students(students)

The output of the above example is shown next.

$ python3 pass_dict.py
  declan: ü¶ã ü¶â ü¶Ç ü¶í
    jill: ü¶Ü ü¶ì ü¶é ü¶Å
     sam: ü¶ñ ü¶Ç ü¶ó
**************************************************
  declan: ü¶ã ü¶â ü¶Ç ü¶í ü¶à
    jill: ü¶Ü ü¶ì ü¶é ü¶Å ü¶à
     sam: ü¶ñ ü¶Ç ü¶ó ü¶à
$

The diagram below shows the variables and references in memory that represent the dictionary of students.

    The dark black represents the students variable defined on line 13 of the code

    The gray indicates the variables inside the update_stickers function.¬≠

Figure 4.1: Variables and references representation

Variable Number of Arguments

Python functions are capable of accepting a variable number of arguments as a single parameter to the function.

    These arguments are either supplied by position or by a keyword.

        A single asterisk in front of the parameter is used for a variable number of positional arguments and the data type of the parameter is always a tuple.

        A double asterisk in front of the parameter is used for a variable number of keyword arguments and the data type of the parameter is always a dict.

The following example defines a function that defines a parameter that takes a variable number of arguments.

    The parameter uses an asterisk in front of it, and as such requires that the arguments be passed positionally when the function is called.

variable_position.py

#!/usr/bin/env python3
def the_sum(*args):
    total = 0
    print("Parameter type:", type(args), end=" ")
    for elem in args:
        total += elem
    return total


total = the_sum(1, 2, 3, 4, 5)
print("Sum is: ", total)
total = the_sum(5, 2, 7)
print("Sum is: ", total)

The output of the above program is shown next.

$ python3 variable_position.py
Parameter type: <class 'tuple'> Sum is: 15
Parameter type: <class 'tuple'> Sum is: 14
$

There may be occasions when you need to define a function that takes a variable number of arguments and several other items.

    Any parameters that are declared after the parameter representing the variable number of arguments must be called as named arguments.

    Such parameters, if not given a default value, are required arguments when the function is called.

varargs.py

#!/usr/bin/env python3
def modify(qty, *values, end="\n"):
    for val in values:
        print(qty * val, end=end)


modify(3, "Hello", "Bye", "Sample", end="|")
print()
modify(4, 10, 20, 30, end=" ~ ")
print()
modify(15, 2, 3, 4)

The output of the above program is shown next.

$ python3 varargs.py
HelloHelloHello|ByeByeBye|SampleSampleSample|
40 ~ 80 ~ 120 ~
30
45
60
$

The example on the following page defines a function that accepts as a parameter a variable number of arguments.

    The parameter uses a double asterisk in front of it, and as such requires that the arguments be passed as keyword arguments when the function is called.

Variable Number of Keyword Arguments

The following example defines a function that accepts as a parameter a variable number of arguments, that when passed will be passed as keyword arguments.

yahtzee_scores.py

#!/usr/bin/env python3
def print_score(player, **scores):
    total_score = 0
    print("Player:", player)
    for category, score in scores.items():
        print("{0:>15}: {1}".format(category, score))
        total_score += score
    print("{0:>15}: {1}".format("Total", total_score))


print_score("Aiden", Aces=4, Twos=8, FullHouse=25, LgStraight=40)
print_score("Cindy", Twos=4, LgStraight=40, Chance=24, ThreeOfAKind=21)

The output of the above program is shown next.

$ python3 yahtzee_scores.py
Player: Aiden
     LgStraight: 40
           Twos: 8
      FullHouse: 25
           Aces: 4
          Total: 77
Player: Cindy
     LgStraight: 40
   ThreeOfAKind: 21
           Twos: 4
         Chance: 24
          Total: 89
$

Scope

In programming languages, the term scope refers to that part of the program where a symbol is known.

Python defines the following scopes.

    local

        local scope refers to the same suite of statements.

        Variables assigned within the same suite are local to the suite.

    global

        Names with the global scope are available to all statements in the module.

        If the developer does not make a variable global, then it is assumed local to the suite.

    built-in

        Names in the built-in scope are defined by Python and are available to all statements in the application.

    nonlocal

        nonlocal scope requires nested functions and is introduced separately in the coming topic of nested functions.

When a symbol (variable name, function name, class name, etc.) is referenced in the application, Python will always search for the symbol in the local scope first.

    If the symbol is not found in the local scope, Python then searches the global scope for the symbol.

    The built-in scope is only searched if the symbol is not found in the local or global scopes.

The examples on the next page demonstrate the difference between a global and a local variable.

local.py

#!/usr/bin/env python3
def demo():
    count = 0
    print("Inside Function:", count)


count = 5
print("Before Function:", count)
demo()
print("After Function: ", count)

The output of the above program is shown next.

$ python3 local.py
Before Function: 5
Inside Function: 0
After Function: 5
$

The following example makes access to the count a global variable inside of the function using the global keyword.

global.py

#!/usr/bin/env python3
def demo():
    global count
    count = 0


count = 5
print("Before Function:", count)
demo()
print("After Function:", count)

The output of the above program is shown next

$ python3 global.py
Before Function: 5
After Function: 0
$

Functions - "First Class Citizens"

Most programmers are comfortable with the notion of sending data to a function.

In Python, it is just as easy to send a function to a function. To understand this, it is important to recognize the difference between the following two notions.

    fun() = invoking the function named fun

    fun = referencing the function named fun

The second of the two forms has some special uses.

    The following example defines a generalized compute function that, in addition to taking a list as an argument, also takes a function.

firstclass.py

#!/usr/bin/env python3
def square(p):
    return p * p


def increment(p):
    return p + 1


def compute(func, lis):
    for index, item in enumerate(lis):
        lis[index] = func(item)


data = [10, 20, 30, 40]
compute(square, data)
print(data)
compute(increment, data)
print(data)

The output of the above program is shown next.

$ python3 firstclass.py
[100, 400, 900, 1600]
[101, 401, 901, 1601]
$

The map Function

Python has several built-in data types that apply a function to each of the elements of an iterable object.

    Examples of iterables include all sequence types (such as list, str, and tuple) and some non-sequence types like dict.

One of these built-in data types is the map data type that has the following syntax.

map(function_name, an_iterable, ...)

The above constructor instantiates an object of type map.

    A map object is an iterator that applies function_name to every item of an_iterable, yielding the results.

    If additional iterable arguments are passed, function_name must take that many arguments and is applied to the items from all iterables in parallel, the iterator stops when the shortest iterable is exhausted.

The example below uses map to convert a list of strings to an iterator of int values.

map_demo.py

#!/usr/bin/env python3
data = ["2", "4", "6", "8"]
values = map(int, data)
print(type(values), ":", values)
total = 0
for value in values:
    total += value
print("Sum of numbers in {} = {}".format(data, total))

The output of the above example is shown next.

$ python3 map_demo.py
<class 'map'> : <map object at 0x7f8d4f11c898>
Sum of numbers in ['2', '4', '6', '8'] = 20
$

The following example demonstrates passing multiple iterables as arguments to the map constructor.

average_grades.py

#!/usr/bin/env python3
tests = {"Sally": (89, 78, 99, 88, 92, 98, 95, 78, 88),
         "Doug": (68, 87, 72, 60, 80, 65),
         "Kesha": (98, 87, 99, 78, 99, 80, 98, 50),
         "John": (89, 78, 99, 88, 92, 99, 95, 88, 95, 99)}


def averages(*grades):
    qty = len(grades)
    return sum(grades)/qty


a, b, c, d = tests.values()
x = map(averages, a, b, c, d)
print("Averages:", list(x))


# Notice that when an asterisk is used on an iterable
# argument when a function is called, that it unpacks the
# iterable automatically into the arguments passed to the
# function as seen below. This * operator when used in
# this manner is often referred to as the "splat" operator
# in other languages.

x = map(averages, *tests.values())
print("Averages:", list(x))

The output of the above program is shown next.

$ python3 average_grades.py
Averages: [86.0, 82.5, 92.25, 78.5, 90.75, 85.5]
Averages: [86.0, 82.5, 92.25, 78.5, 90.75, 85.5]
$

filter

Another built-in data type is the filter data type that has the following syntax.

filter (function_name, an_iterable)

The above constructor instantiates an object of type filter.

    A filter object is an iterator that applies function_name to every item of an_iterable, yielding all the results for which the function returns True.

filter_demo.py

#!/usr/bin/env python3
def multiple_of_three(x):
    return x % 3 == 0


results = filter(multiple_of_three, range(2, 51))
for value in results:
    print(value, end=' ')
print()

The output of the above program is shown next.

$ python3 filter_demo.py
3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48
$

A Dictionary of Functions

The following is an example of creating a menu whose keys map to functions.

function_menu.py

#!/usr/bin/env python3
def add():
    val = input("Enter value to add: ")
    data.append(val)


def delete():
    item = data.pop(0)
    print("removing", item)


def display():
    print("displaying:", data)


def terminate():
    print("terminating")
    exit()


def illegal():
    print("Illegal Selection\n")


data = []
menu = {"1": add, "2": delete, "3": display, "4": terminate}
keys = sorted(menu.keys())
while True:
    print("Make selection:")
    for key in keys:
        print("\t", key, menu[key].__name__)
    key = input(">")

    menu.get(key, illegal)()

When a user selects a menu item, that value is used as the key into the dictionary in menu.get(key, illegal)().

The empty parenthesis at the end invoke the function being referenced by the value returned from the get method.

Nested Functions

In Python, a function can be nested inside another function.

The inner function will have access to any variables in the scope of the outer function.

nested.py

#!/usr/bin/env python3
def outer(a, b):
    x = 15
    y = 20

    def inner(z):
        print(a, b, x, y, z)

    return inner  # a reference to inner function


result = outer(5, 10)
print(type(result))
result(9)  # invoke the returned function

The output of the above program is shown next.

$ python3 nested.py
<class 'function'>
5 10 15 20 9
$

The example above demonstrates a few principles.

    A function can return another function.

    When the nested function is defined, its variables can reference variables from the containing scope.

        If the inner function needs to modify the value of a variable from the containing scope it must declare access to the variable is being done as nonlocal scope.

lambda

Python supports the runtime creation of anonymous functions (functions that are not bound to a name) using a lambda expression.

This is a powerful concept and one that is often used in conjunction with functions and data types, such as filter and map.

    lambda expressions must be one-liners.

    The parameters are defined before the colon.

    The work of the function is defined after the colon.

    A return statement is unnecessary.

The following example uses a lambda as the function to be passed to the filter function.

filter_with_lambda.py

#!/usr/bin/env python3
results = filter(lambda x: x % 3 == 0, range(2, 51))

for value in results:
    print(value, end=' ')
print()

The next example is a rewrite, of the previous nested functions example, that defines the inner function as a lambda.

nested_lambda.py

#!/usr/bin/env python3
def outer(a, b):
    x = 15
    y = 20

    return lambda z: print(a, b, x, y, z)


result = outer(5, 10)
print(type(result))
result(9)  # invoke the returned function

Recursion

One advanced form of defining and using a function is known as recursion.

A recursive function is a function that calls itself that has the following two features:

    A call to itself.

    A termination condition, when the function does not call itself.

Recursion is often a conceptually easier way of describing a problem, but sometimes has a tendency to become less efficient due to the possibly large number of function calls involved.

The following example is a recursive function that adds numbers from 1 to and upper limit n.

recursive_sum.py

#!/usr/bin/env python3
def sum_to(n):
    if not n:     # This is the termination condition
        return n

    return n + sum_to(n-1)  # This is where the recursion is


limit = 6
print("Sum from 1 to", limit, "is:", sum_to(limit))

The last line of code inside of the sum_to function recursively calls the same function.

    The if statement on line 3 of the code acts as the terminating condition where the function no longer calls itself.

The following example rewrites the above code to include additional print statements to get a better understanding of the intermediate steps throughout the recursive calls.

recursive_sum_verbose.py

#!/usr/bin/env python3
indent = 0
text = "sum_to"


def sum_to(n):
    global indent
    print(" " * indent, text, n)
    indent += 1
    if not n:
        indent -= 1
        print(" " * indent, text, n, " => ", n)
        return n
    result = sum_to(n - 1)
    indent -= 1
    print(" " * indent, text, n, end="")
    print(" => {0:2} + {1:2} => {2:2}".format(n, result, n + result))
    return n + result


limit = 6
print("\nSum from 1 to", limit, "is:", sum_to(limit))

The added print statements show the values of n and result through each recursive call to sum_to as shown next.

$ python3 recursive_sum_verbose.py
 sum_to 6
  sum_to 5
   sum_to 4
    sum_to 3
     sum_to 2
      sum_to 1
       sum_to 0
       sum_to 0 => 0
      sum_to 1 => 1 + 0 => 1
     sum_to 2 => 2 + 1 => 3
    sum_to 3 => 3 + 3 => 6
   sum_to 4 => 4 + 6 => 10
  sum_to 5 => 5 + 10 => 15
 sum_to 6 => 6 + 15 => 21

Sum from 1 to 6 is: 21
$

Recursion is often a more elegant approach to solving a problem, but can result in lessened performance.

    A call such as sum_to(50) will make 50 function calls, whereas an iterative approach may only require one.

Python has a limit called the recursion limit.

    If a function recursively calls itself too many times, it will raise an exception of type RecursionError.

    While this limit can be changed, hitting the limit should act as a red flag that the recursive call may be to inefficient to use.

The example below is an iterative approach to the problem as opposed to the previous recursive approach.

iterative_sum.py

#!/usr/bin/env python3
def iterative_sum_to(n):
    total = 0
    for i in range(n, 0, -1):
        total += i
    return total


limit = 6
print("Sum from 1 to", limit, "is:", iterative_sum_to(limit))

Exercises

The solution files for these exercises are in the AD141-apps repository, within the functions/solutions directory.
Exercise 1

Write and test a function that is designed to validate input.

    The function should prompt the user for a positive integer.

    It should validate the information entered by the user is indeed a positive integer.

        If number entered is valid, the function should return the number.

        If the number entered is invalid, the function should return a zero (0) instead.

    The application, not the function, should indicate with a message in the output each time an invalid entry is given.

Exercise 2

Write and test a function that takes a collection of strings and returns the length of the longest string in the collection.

    The application should loop through the collection of strings and rely on the value returned by the function to format all of the strings to the output such that they are all right justified to the width of the longest string.

Exercise 3

There is a built-in function in Python called sum that will return the sum of all of the numbers of an iterable object.

    Write a similar function, but instead of taking a collection as a parameter, the function should take a variable number of arguments and return the sum of them.

Exercise 4

Rewrite the function in Exercise 3 above to return a tuple instead of a sum.

    The tuple should be the sum and the average of all of the arguments passed to the function.

Exercise 5

Write a calculator application that presents the following menu:

Calculator options:
      1. Add
      2. Subtract
      3. Multiply
      4. Divide
      5. Quit

    The user is expected to enter a number from the above menu.

        After choosing the operation, the user should be prompted twice for 2 numbers and the chosen operation performed on them with the result being displayed on the screen.

        Each of the above options should be implemented as its own function.

Exercise 6

Write and test a function that receives a list as its only parameter and returns a new list of the positive elements only.
Exercise 7

Write and test a function that takes a variable number of arguments as its first parameter and a number as its second parameter.

    The function should return the count of the values in the tuple parameter (the variable number of arguments) that are greater than the second parameter (num in the sample below).

    For example, one such call to a function named positive is shown below.

res = positive(5, -10, 10, -20, 30, num=0)

    In this case, the function would return a value of 3.

Exercise 8

Write a function that returns a nested function.

    When the nested function is executed it should return the sum of two integers.

    The two parameters should be passed to the outer function and used by the inner function.

Exercise 9

Re-write your solution to Exercise 8 such that the outer function receives no parameters, and the nested function is defined as taking the two parameters.
Exercise 10

Re-write your solution to either Exercise 8 or 9 so that it uses a lambda expression as the nested function.
Exercise 11

Write and test a function that takes two lists as parameters and returns a list of the elements that are common to both.
Exercise 12

Write and test a function that takes a number and a dictionary and adds the number to all values in the dictionary.

    You can assume that all the values in the dictionary are numbers.

Exercise 13

While the index method of a list can be used to find either the first occurrence of an item or the first occurrence of it within a range of the list, it does not allow you to find, say the second or third occurrence by passing in a number as to the one you are looking for.

    Write a function that takes 3 parameters and returns what it finds.

        One being the list to search.

        The second being the object to search for.

        The thrid being an int representing which one you are looking for such as the fist, second, third occurrence.

    The index method raises a ValueError exception if the value being searched for does not exit in the list.

        It is perfectly fine for your function to behave in the same manner.

References

More information about docstring conventions can be found in PEP 257 at the following URL https://www.python.org/dev/peps/pep-0257/ 