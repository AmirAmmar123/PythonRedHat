Chapter 8.  Input and Output

Input and Output
Summary

Abstract

Goal 	

Read and write sequences of bytes in input and output data streams.
Objectives 	

    Use Python's additional I/O capabilities beyond the input and print functions.

    Create and use data streams to read and write to files.

    Read and write to text files.

    Use bytes and bytearray data types to read and write binary files.

    Use the seek and tell methods to randomly access the stream contents.

    Use the os and os.path modules to work with files and directories.

Sections 	

    Input and Output

Input and Output
Objectives

    Use Python's additional I/O capabilities beyond the input and print functions.

    Create and use data streams to read and write to files.

    Read and write to text files.

    Use bytes and bytearray data types to read and write binary files.

    Use the seek and tell methods to randomly access the stream contents.

    Use the os and os.path modules to work with files and directories.

Introduction

Up to this point in the course, the discussion of input and output has been limited to the input() and print() functions.

    This chapter introduces additional ways in which Python programs can read and write to and from various sources, other than the standard input and output files.

An input data stream is an object that provides data to the application as a sequence of bytes.

    sys.stdin is the data stream that represents the operating system's standard input device - usually the keyboard.

An output data stream is an object used by an application for writing data out as a sequence of bytes.

    sys.stdout is the data stream that represents the standard output device - usually the system console.

    sys.stderr is the data stream that represents the standard error device - usually the system console.

Although stdin, stdout, and stderr data streams are opened by Python automatically, the sys module must be imported to access them directly.

sys_io.py

#!/usr/bin/env python3
import sys


def main():
    sys.stdout.write("Please enter some text:\n")
    x = sys.stdin.readline()
    # Use of literal fstring instead of format method
    sys.stdout.write(f"Standard Output\n{x}")
    sys.stderr.write(f"Error Output\n{x}")


if __name__ == "__main__":
    main()

Creating Your Own Data Streams

The built-in open() function opens a file and returns a data stream.

When opening a data stream, you must declare it as an input data stream, or as an output data stream.

If the open() function fails, then a subclass of OSError is raised.

The open() function accepts multiple arguments:

    It has a required string as its first argument, representing the name of the file.

    There is also an optional argument named mode, that among other things is used to declare the type of data stream it should create.

References

A complete list of named arguments and their meanings can be found in the documentation for the open() function here: https://docs.python.org/3/library/functions.html#open

The following table lists the different values that can be used to specify the mode in which the file is opened.

Table 8.1. File Opening Modes
Mode	File Opened For:
r 	Reading (default). It fails if the file does not exist.
w 	Writing. It truncates the file if it already exists.
x 	Exclusive creation. It fails if the file already exists (added in Python 3.3).
a 	Appending to end of file. It creates the file if it does not exist.
b 	Binary mode.
t 	Text mode (default).
+ 	Updating (reading and writing).

    As an example, mode="w+b" would open a file for binary read-write access.

    Once a stream is opened, various methods can then be used to read and write files.

Writing to a Text File

Here is a simple program that writes data to a file.

    When the program is run, the print statements output information about the stream returned by the call to open().

    The calls to write() will output to the file rather than the display.

    Finally, the close() function closes the stream.

        It is always recommended to close a stream you opened after you are finished processing it.

write1.py

#!/usr/bin/env python3
def main():
    f = open('output', 'w')
    print("Type:", type(f).__name__, "\tModule:", type(f).__module__)
    f.write('This is a test.\n')
    f.write('This is another test.\n')
    f.close()


if __name__ == "__main__":
    main()

The file name could be given as a command line argument or as user input.

    Note the use of a shorthand if statement to determine the file name.

write2.py

#!/usr/bin/env python3
import sys


def main():
    filename = sys.argv[1] if len(sys.argv) > 1 else input("Enter file name: ")
    f = open(filename, 'w')
    f.write('This is a test.\n')
    f.close()


if __name__ == "__main__":
    main()

The write() function can only write strings. Any data that is not text will have to be converted first.

write3.py

#!/usr/bin/env python3
import datetime


def main():
    f = open('output', 'w')
    data = [1, 2, 3]
    today = datetime.datetime.today()
    # f.write(today)  ~ Will not work since not a string
    f.write(str(data) + "\n")
    f.write(str(today) + "\n")
    f.close()


if __name__ == "__main__":
    main()

The following program appends data to a file and uses the writelines() method, which writes all the elements of a list of strings passed as a parameter.

writelines.py

#!/usr/bin/env python3
def get_data():
    the_list = []
    while True:
        data = input("Enter data ('q' to exit): ")
        if data == "q":
            break
        the_list.append(data)
    return the_list


def main():
    data = get_data()
    f = open("output", "a")
    f.writelines(data)
    f.close()


if __name__ == "__main__":
    main()

The print() function can also be used to write data to a file.

    The named parameter, file, can be used to specify an output file.

print1.py

#!/usr/bin/env python3
from datetime import datetime


def main():
    f = open("output", "w")
    cnt = 1
    while True:
        data = input("Enter data ('q' to exit): ")
        if data == "q":
            break
        txt = "{:04}".format(cnt)
        print(txt, datetime.today(), data, file=f)
        cnt += 1
    f.close()


if __name__ == "__main__":
    main()

When dealing with stream objects, it is good practice to use the with keyword.

    This has the advantage that the stream is properly closed after finishing its processing.

print2.py

#!/usr/bin/env python3
def main():
    with open("output", "w") as a_file:
        while True:
            data = input("Enter data ('q' to exit): ")
            if data == "q":
                break
            print(data, file=a_file)

    print("File Is Now Closed? ", a_file.closed)


if __name__ == "__main__":
    main()

Reading From a Text File

The following functions can be used to read data once a stream has been opened for reading.

    read()

        For reading an entire stream into a string.

        The number of characters to be read can be controlled by specifying the number of bytes to read at a time as a parameter.

    readline()

        For reading a single line into a string, retaining newline character(s).

        Returns an empty string when there is no more data to read.

    readlines()

        For reading an entire stream into a list, where each element of the list contains a line from the stream.

The following program uses the readline method to read a line at a time from a file.

    It counts the number of lines and characters in a file.

read1.py

#!/usr/bin/env python3
def main():
    char_count = line_count = 0
    with open(input("Enter a file name: "), "r") as a_file:
        while True:
            txt = a_file.readline()
            if not txt:
                break
            char_count += len(txt)
            line_count += 1

    print("Characters:", char_count, " Lines:", line_count)


if __name__ == "__main__":
    main()

A stream object in Python is iterable, so it can be read from in a for loop.

read2.py

#!/usr/bin/env python3
def main():
    with open(input("Enter a file name: "), "r") as the_file:
        for a_line in the_file:
            print(a_line, end="")


if __name__ == "__main__":
    main()

The readlines() method reads the entire contents of a stream into a list of strings.

    Similar to the readline() method, all newline characters are retained.

    Each line from the stream is an element in the resulting list.

read3.py

#!/usr/bin/env python3
def main():
    with open(input("Enter a file name: "), "r") as the_file:
        the_lines = the_file.readlines()
    for a_line in the_lines:
        print(a_line, end="")


if __name__ == "__main__":
    main()

The read() method reads the data and returns it as a string.

    Passing no arguments will cause it to read the whole stream.

    Passing in a number as an argument indicates the quantity of data to be read.

The following example incorporates exception handling in addition to demonstrating the read() method.

    It also utilizes the built-in string module to easily obtain the letters of the alphabet.

read4.py

#!/usr/bin/env python3
import string


def main():
    try:
        with open("alphabet", "w") as the_file:
            the_file.write(string.ascii_letters)
        print("The following was written to the file:")
        print(string.ascii_letters, "\n")

        with open("alphabet", "r") as the_file:
            while True:
                the_text = the_file.read(10)
                if not the_text:
                    break
                print(the_text)
    except OSError as err:
        print("IO Error:", err)


if __name__ == "__main__":
    main()

The execution output of the preceding program might be as follows:

$ python3 read3.py
The following was written to the file:
abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ

abcdefghij
klmnopqrst
uvwxyzABCD
EFGHIJKLMN
OPQRSTUVWX
YZ
$

    The read() method from the preceding example reads 10 characters at a time.

    The second to last call to read() returned the two remaining characters because the total number of characters was not a multiple of 10.

    The last call to read() returned an empty string, which resulted in breaking out of the while loop.

bytes and bytearray Objects

The examples in this chapter, up to this point, have focused on reading and writing text files as opposed to binary files.

    The open() function has returned a TextIOWrapper object which expects and produces str objects to read and write.

    Writing and reading to and from binary files deal with bytes and bytearray objects instead of strings.

    No encoding, decoding, or newline translation is performed.

A bytearray object is a mutable sequence of integers in the range 0 >= x < 256.

    It has most of the usual methods of mutable sequences.

    It also has most of the methods that a bytes object has.

A bytes object is an immutable sequence of integers in the range 0 >= x < 256.

    A bytes object is an immutable version of bytearray.

    The syntax for a literal bytes object is similar to that of string literals, except that a b prefix is added:

 b'this is a bytes object'
 b"this is also a bytes object"

Converting between strings and bytes can be done by using the bytes decode() and the str encode() methods.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> x = b"Goodbye"
>>> y = "Hello"
>>> print(type(x), type(y))
<class 'bytes'> <class 'str'>
>>> x = x.decode()
>>> y = y.encode()
>>> print(type(x), type(y))
<class 'str'> <class 'bytes'>

Reading and Writing Binary Files

The following example reads and writes binary text by using bytes and bytearray objects.

binary_io.py

#!/usr/bin/env python3
def main():
    text = "This is a string of data to be written\n"
    some_bytes = b"This should also be written to the file\n"
    a_byte_aray = bytearray("Hello", "utf-8")
    more_bytes = bytes("\nConverting this to bytes", "ascii")
    try:
        # Write to the file
        with open("binarydata", "wb") as the_file:
            print("Type of stream:", type(the_file).__name__)
            print("Module:", type(the_file).__module__)
            the_file.write(text.encode())
            the_file.write(some_bytes)
            the_file.write(a_byte_aray)
            the_file.write(more_bytes)

        # Read from the file
        with open("binarydata", "rb") as the_file:
            buffer = b''
            while True:
                the_text = the_file.read(10)
                if not the_text:
                    break
                buffer += the_text
        print(buffer)
        print("*" * 50)
        print(buffer.decode())
    except OSError as err:
        print("OS Error:", err)


if __name__ == "__main__":
    main()

Random Access

The seek() method on a file object provides arbitrary random access (seeking forwards or backwards to any location) within the file.

    The syntax for the method is seek(offset[, whence])

    The method changes the stream position to the given byte offset.

    The offset is interpreted relative to the position indicated by the optional parameter whence.

    The os module defines three int constants (SEEK_SET, SET_CUR, and SEEK_END) for the values of whence.

The table below shows the valid values for the whence argument.

    It lists the constant name, the constant value as an int, and the constant meaning.

Table 8.2. whence Argument Values
Constant	Value	Meaning
os.SEEK_SET 	0 	Start of the stream (default). The offset should be zero or positive.
os.SEEK_CUR 	1 	Current stream position. The offset may be negative.
os.SEEK_END 	2 	End of the stream. The offset is usually negative

    Seeking relative to the current position and end position requires an offset of 0 (os.SEEK_SET) when working in text mode.

The tell() method returns the current position as the byte offset from the beginning of the file.

The following example demonstrates the use of the seek() and tell() methods while reading and/or writing files.

    The file read in the example contains the 26 letters of the alphabet.

seek1.py

#!/usr/bin/env python3
import os


def main():
    fmt = "CursorStart:{:<3}  Offset:{:<3}  Read:{:<3} " +\
          "CursorEnd:{:<3}  Data:{}"
    # Reading from file in binary mode
    with open("seekdata.txt", "rb") as f:
        offset, whence, chunk = (-20, os.SEEK_END, 5)
        f.seek(0, whence)
        start = f.tell()
        f.seek(offset, whence)
        data = f.read(chunk)
        print(fmt.format(start, offset, chunk, f.tell(), data))

        offset, whence, chunk = (3, os.SEEK_CUR, 7)
        start = f.tell()
        f.seek(offset, whence)
        data = f.read(chunk)
        print(fmt.format(start, offset, chunk, f.tell(), data))


if __name__ == "__main__":
    main()

The execution output of the preceding program might be as follows:

$ python3 seek1.py
CursorStart:26 Offset:-20 Read:5 CursorEnd:11 Data:b'GHIJK'
CursorStart:11 Offset:3 Read:7 CursorEnd:21 Data:b'OPQRSTU'
$

Working With Files and Directories

When reading and writing files, the os and os.path modules provide a variety of functions for working with files and directories.

Table 8.3. os Module
Name	Behavior
os.chdir() 	Changes the current working directory.
os.getcwd() 	Returns a string representing the current working directory.
os.listdir() 	Returns a list containing the names of the entries in a directory.
os.mkdir() 	Creates a directory for a given path.
os.makedirs() 	Recursive directory creation, creates all intermediate-level directories required to contain the leaf directory.
os.remove() 	Deletes a file path. If the path is a directory, then an OSError exception is raised.
os.rmdir() 	Deletes the directory path. It only works when the directory is empty.
os.rename() 	Renames a file or directory.
os.chown() 	Changes the owner and group ID of a given path.
os.chmod() 	Changes the mode of a given path.
os.stat() 	Gets the status of a file as an os.stat_result object.
os.getenv() 	Returns the value of an environment variable.
os.path.isabs() 	Returns True if the path is an absolute pathname.
os.path.isfile() 	Returns True if the path is an existing regular file.
os.path.isdir() 	Returns True if the path is an existing directory.
os.path.dirname() 	Returns the directory name of a path name.
os.path.exists() 	Returns True if the path refers to an existing path or an open file descriptor.
os.path.getsize() 	Returns the size, in bytes, of a given path.
os.path.join() 	Joins one or more path components by using the property directory separator.

The os.stat_result object has the following properties.

Table 8.4. os.stat Object Properties
Index	Attribute	Meaning
0 	st_mode 	File mode (type and permissions).
1 	st_ino 	The inode number.
2 	st_dev 	Device number of the file system.
3 	st_nlink 	Number of hard links to the file.
4 	st_uid 	Numeric user ID of file's owner.
5 	st_gid 	Numerical group ID of file's owner.
6 	st_size 	Size of the file in bytes. Same value as the one returned by os.path.getsize().
7 	st_atime 	Last access time (seconds since epoch). Same value as the one returned by os.path.getatime().
8 	st_mtime 	Last modify time (seconds since epoch). Same value as the one returned by os.path.getmtime().
9 	st_ctime 	

Linux: Last inode change time (seconds since epoch).

Windows: Creation time (seconds since epoch). Same value as the one returned by os.path.getctime().

The following application demonstrates many of the functions available in the os and os.path modules.

filestats.py

#!/usr/bin/env python3
import sys
import os
import time


def fileinfo(files):
    maxlength = str(len(max(files, key=len)))
    # Use of ^ for centering and the use of a nested {}  ~   {:>12{}⁠}
    fmt = "{:" + maxlength + "} {:^9} {:^9} {:^9} {:>12{}⁠}"
    pieces = ("Name:", "Exists?", "File?", "Dir?", "Size(bytes)", "")
    # Use of *pieces to splat pieces into an argument list
    print(fmt.format(*pieces))
    for afile in files:
        print(fmt.format(afile, str(os.path.exists(afile)),
                         str(os.path.isfile(afile)), str(os.path.isdir(afile)),
                         os.path.getsize(afile), ","))


def allstats(afile):
    tag = ["mode", "inode#", "device#", "#links", "user", "group", "bytes",
           "last access", "last modified", "change/creation time"]
    print("File Stats for:", afile)
    stats = os.stat(afile)
    fmt = "{:>22} : {}"
    for i, stat in enumerate(stats):
        print(fmt.format(tag[i], stat))


def datestats(afile):
    print("More Stats for:", afile)
    stats = os.stat(afile)
    print("Last Access:", time.ctime(stats.st_atime))
    print("Last Modified:", time.ctime(stats.st_mtime))
    print("Last Change:", time.ctime(stats.st_ctime))


def main():
    cwd = os.getcwd()
    print("Current Directory:", cwd)
    newdir = "afolder/asubfolder"
    os.makedirs(newdir, exist_ok=True)

    # Get list of files and get info about first 5
    filelist = sorted(os.listdir(cwd))[:5]
    fileinfo(filelist)

    # Get stats on a file
    allstats(sys.argv[0])
    datestats(sys.argv[0])


if __name__ == "__main__":
    main()

Exercises

The solution files for these exercises are in the AD141-apps repository, within the io/solutions directory.
Exercise 1

Write a program that counts the number of lines, words, and characters in each file named on the command line.
Exercise 2

Revise Exercise 1 so that it accepts as an optional first command line argument a -t option.

    The program must then only print the total number of lines, words, and characters in all the files combined.

Exercise 3

Write a program that asks the user for the names of an input and an output file.

    Open both of these files and then have the program read from the input file (by using readline()) and write to the output file (by using write()).

    In effect, this is a copy program, whose interface to the program might look like:

Enter the name of the input file: myinput
Enter the name of the output file: myoutput

Exercise 4

Rewrite Exercise 3 such that the file names are obtained from the command line if two arguments are supplied.

    If the number of arguments is not two, then it should fall back on prompting the user for the filenames.

    The interface might look like:

python3 your_program_name.py inputfile outputfile

Exercise 5

Add exception handling to the previous exercise so that if a file open fails, an OSError exception is handled, and the program is halted.
Exercise 6

Write a program that displays the file name, size, and modification date for all those files in a directory that are greater than a given size.

    The directory name and the size criteria are given as command line arguments.

Exercise 7

Create two data files, each with a set of names, one per line.

    Now, write a program that reads both files and lists only those names that are in both files.

    The two file names should be supplied on the command line.

Exercise 8

Now, create a few more files with one name per line.

    The program in this exercise should read all these files and print the number of times each line occurs over all the files.

    The file names should be supplied on the command line.

    The following files are available in the AD141-apps repository, within the io/starter directory, and you can use them in the exercise:

names_a.txt
names_b.txt
names_c.txt
names_d.txt

    The output from the program might be as follows:

Alice       4
Bart        2
Beverly     1
Bill        4
Chris       2
Dave        1
Frank       3
Jane        3
John        2
Mary        1
Mike        4
Peter       3
Susan       2

References

A complete list of named arguments and their meanings can be found in the documentation for the open() function here: https://docs.python.org/3/library/functions.html#open 