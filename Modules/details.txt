Chapter 5.  Modules

Modules
Summary

Abstract

Goal 	

Reuse code organized and grouped into independent files.
Objectives 	

    Use modules to hold Python definitions and statements.

    Define and access modules from other modules.

    Use the dir function to list available symbols with a module's global scope.

    Check the index of Python standard library modules for modules that may be helpful.

    Understand and use the various properties and functions of Python's sys module.

    Write programs that use various numeric and mathematical modules from Python's standard library.

    Write programs that use the various date and time modules from Python's standard library.

Sections 	

    Modules

Modules
Objectives

    Use modules to hold Python definitions and statements.

    Define and access modules from other modules.

    Use the dir function to list available symbols with a module's global scope.

    Check the index of Python standard library modules for modules that may be helpful.

    Understand and use the various properties and functions of Python's sys module.

    Write programs that use various numeric and mathematical modules from Python's standard library.

    Write programs that use the various date and time modules from Python's standard library.

What is a Module?

By using functions, we can better organize our code for reuse within a program.

    As your scripts get longer, you may want to split them into several files for easier maintenance.

    You may also want to use a handy function that you have written in several programs without copying its definition into each program.

Python has a way to put definitions in a file and use them in a script or in an interactive instance of the interpreter. Such a file is called a module.

A module is a file containing Python definitions and statements.

    The module name is the file name without the .py extension.

    Definitions from a module can be imported into other modules or into the main module.

    The main module (named __main__) is the collection of variables that you have access to in a script executed at the top level of a script and in an interactive Python shell.

Within a module, the module's name is accessible via the value of the global variable __name__.

The following example defines several functions, that can be used by multiple Python applications, in a file named reusable.py.

    When the reusable module is run from the command line, its acts as the main module and as such is assigned a __name__ of __main__ when loaded.

    The statements in the module that invoke the functions are placed inside of a conditional statement that only runs when the module's name is __main__.

The example and its output is shown on the following page.

Modules

reusable.py

#!/usr/bin/env python3
def main():
    print("Testing my functions at top level", square(5), cube(10))


def square(p):
    return p ** 2


def cube(p):
    return p ** 3


if __name__ == "__main__":
    main()

$ python3 reusable.py
Testing my functions at top level 25 1000
$

Placing the application code in a function called main and calling it conditionally as shown above is a very Pythonic way of defining a Python application.
Note

Pythonic means code that follows the conventions of the Python community. You can learn more about this coding style in the following URL.

https://peps.python.org/pep-0008/

Applications desiring to use the above functions must import the reusable.py file by its module name.

app.py

#!/usr/bin/env python3
import reusable


def main():
    print(reusable.square(5), reusable.cube(5))


if __name__ == "__main__":
    main()

When the app module in the previous example is run from the command line, its name becomes __main__.

    Upon importing the reusable module, the if statement in the reusable module does not execute the main function because it's name is reusable in this context instead of __main__.

Each module has its own symbol table, which contains the identifiers (names) used in that module.

    Many languages refer to these symbol tables as namespaces.

    In the absence of any imported modules, Python always looks for names in the namespace of the main module.

    To direct Python to look into another module in order to resolve a name, use the module name ahead of the function name, as in the code next.

result = reuseable.square(5)

Alternately, you can import the entire reuseable symbol table into that of the currently running main module.

alternate.py

#!/usr/bin/env python3
from reusable import *


def main():
    print("Module name is: " + __name__)
    print(square(5), cube(5))


if __name__ == "__main__":
    main()

    The * wildcard used above does not actually import all of the module's symbols into the top level symbol table.

        It ignores any symbols that start with an underscore.

        If a list of strings named __all__ is found in the module, only the symbols named in the list are imported into the namespace.

The dir Function

The built-in dir function determines which symbols a module defines.

    It returns a sorted list of strings.

        When called with no parameters, it returns the symbols available in the main module.

        When a module name is passed as an argument, it returns a list of all of the symbols available in that module's symbol table.

The interactive Python shell below demonstrates various calls to the built-in dir() function.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__','__name__',
'__package__', '__spec__']
>>> x = 99
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__','__name__',
'__package__', '__spec__', 'x']
>>> import reusable
>>> dir()
['__annotations__', '__builtins__', '__doc__', '__loader__','__name__',
'__package__', '__spec__', 'reusable', 'x']
>>> dir(reusable)
['__builtins__', '__cached__', '__doc__', '__file__','__loader__', '__name__',
'__package__', '__spec__', 'cube', 'main','square']
>>> exit()
$

A full list of the built-in symbols available to all modules can be seen by passing the variable __builtins__ to the dir() function.

 dir(__builtins__)

Python Standard Library Modules

Python comes with a library of standard modules, some of which are built into the interpreter.

    These provide access to operations that are not part of the core language but are built in, often either for efficiency or to provide access to operating system specific calls.

References

The modules available from the Python standard library, and their documentation, can be found at the following URL: https://docs.python.org/3/library/index.html

    Many of the modules provide standardized solutions for many problems that occur in everyday programming.

    Some are designed to encourage and enhance the portability of Python programs by providing platform-neutral APIs.

There is a growing public collection of thousands of components, from individual programs to entire frameworks, available from the Python Package Index (PyPi).

    Keep in mind the following if using anything from the PyPi repository.

        Arbitrary Python code can be executed during the installation.

        Anyone can register an account and upload Python packages to the PyPi repository requiring trust of the maintainer of the package as to the safety of its contents.

References

The PyPi repository can be found at the following URL: https://pypi.python.org/pypi

    Installation of packages from the repository is often done through a package management system named "pip".

The remainder of this chapter will focus on several commonly used modules that are part of the Python Standard Library.

The sys Module

The sys module provides access to variables and functions to interact with the interpreter. The following are several of the available properties and functions available in the module.

    sys.path

        A list of strings that specifies the search path for modules.

        Includes values from the environment variable PYTHONPATH.

        The first item of this list, sys.path[0], is the directory containing the script that was used to invoke the Python interpreter.

    sys.argv

        A list of command line arguments passed to a Python script, where sys.argv[0] is the script name.

    sys.version_info

        A tuple containing the five components of the version number: major, minor, micro, releaselevel, and serial.

        The values can be obtained by index or by name, sys.version_info[0] or sys.version_info.major for example.

    sys.exit([arg])

        Exits from Python. The optional argument arg can be an integer giving the exit status (defaulting to zero), or another type of object.

        If it is an integer, zero is considered “successful termination” and any nonzero value is considered “abnormal termination” by shells and the like.

        sys.exit("Some error message") would exit a program with the given message and an exit status of 1.

References

The sys module's complete list of properties and functions and their documentation can be found at the following URL: https://docs.python.org/3/library/sys.html

    The properties and functions listed above for the sys module are shown in the example on the following page.

sys_testing.py

#!/usr/bin/env python3
import sys


def main():
    print("Script Name:", sys.argv.pop(0))
    print("Remaining Command Line Arguments:", sys.argv)

    info = sys.version_info
    print("Python Version:")
    print(info.major, info.minor, info.micro, sep=".")

    print("Python Path:")
    for each_path in sys.path:
        print("\t", each_path)
    print()

    number = input("Please enter an integer")
    if not number.isdecimal():
        sys.exit(number + " is not an integer.")

    print("You entered the number " + number)


if __name__ == "__main__":
    main()

Numeric and Mathematical Modules

There are various modules in the Python Standard Library that deal with numeric and math-related functions and data types.

    The math module contains functions for floating-point numbers.

    The decimal module provides a data type that supports correctly-rounded decimal floating point arithmetic.

    The random module provides a pseudo-random number generator.

numbers_and_math.py

#!/usr/bin/env python3
import math
import decimal
import random


def math_examples():
    print("Square Root of 10:", math.sqrt(10))
    print("64 to 3/2 pow:", math.pow(64, 1.5))
    print("Hypotenuse of 6 and 8:", math.hypot(6, 8))
    print("Smallest integer >= 2.5", math.ceil(2.5))
    print("Pi", math.pi)


def decimal_examples():
    print(".1 + .2 is not normally thought of as", .1 + .2)
    d1, d2 = decimal.Decimal(".1"), decimal.Decimal(".2")
    print("It is normally:", d1 + d2)


def random_examples():
    data = [9, 8, 7, 6, 5, 4, 3, 2]
    print(" float 0.0 <= x < 1.0:", random.random())
    print(" int from 0 to 9:", random.randrange(10))
    print(" choice ", data, ":", random.choice(data))
    random.shuffle(data)
    print(" shuffled", ":", data)
    print(" sample ", data, ":", random.sample(data, 4))

An application that calls all three of the above methods is shown on the following page.

numbers_and_math_test.py

#!/usr/bin/env python3
from numbers_and_math import math_examples, decimal_examples, random_examples


def main():
    examples = [math_examples, decimal_examples, random_examples]
    for function in examples:
        print(function.__name__.upper(), "*" * 50)
        function()


if __name__ == "__main__":
    main()

The output of the above program is shown next.

$ python3 numbers_and_math_test.py
MATH_EXAMPLES **************************************************
Square Root of 10: 3.1622776601683795
64 to 3/2 pow: 512.0
Hypotenuse of 6 and 8: 10.0
Smallest integer >= 2.5 3
Pi 3.141592653589793
DECIMAL_EXAMPLES ***********************************************
.1 + .2 is not normally thought of as 0.30000000000000004
It is normally: 0.3
RANDOM_EXAMPLES ************************************************
 float 0.0 <= x < 1.0: 0.9254105346291956
 int from 0 to 9: 2
 choice  [9, 8, 7, 6, 5, 4, 3, 2] : 9
 shuffled : [2, 3, 9, 4, 6, 5, 7, 8]
 sample  [2, 3, 9, 4, 6, 5, 7, 8] : [3, 6, 9, 2]
$

The shuffle() function of the random module updates the sequence passed to it in place as opposed to returning a new sequence of the results.
References

Many of the standard modules that deal with numbers and math can be found in the Python documentation at the following URL: https://docs.python.org/3/library/numeric.html

Time and Date Modules

There are various modules in the Python Standard Library that deal with time and date functions and data types.

    We cover the`datetime`, calendar and time modules in this section.

The datetime module provides data types for manipulating both dates and times in both simple and complex ways.

The datetime modules defines many practical data types, some of which are listed here:

    datetime.date - represents a date (year, month and day).

    datetime.time – represents a local time of day.

    datetime.datetime – represents all the information from a datetime.date and a datetime.time object.

    datetime.timedelta - represents a duration between two dates or times.

References

The following URL provides a complete list of data types provided by the datetime module: https://docs.python.org/3/library/datetime.html

The example on the following page demonstrates both the datetime and timedelta data types from the datetime module.

    The code demonstrates various ways of creating a datetime object through its constructor and other methods of the class.

    It also demonstrates the creation and use of a timedelta object to modify a datetime object.

dates_and_times.py

#!/usr/bin/env python3
from datetime import datetime, timedelta


def main():
    end = "\n\n"
    now = datetime.today()
    print("Today is:", now)
    print(now.month, now.day, now.year, sep="/", end=end)

    delta = timedelta(days=1, hours=12)
    future = now + delta
    print("36 hours from now:", future, end=end)

    past = datetime(2000, 1, 31, 14, 25, 59)
    print("A date in the past:", past, end=end)


if __name__ == "__main__":
    main()

The output of the above program is shown next.

$ python3 dates_and_times.py
Today is: 2018-09-24 16:50:47.224852
9/24/2018
36 hours from now: 2018-09-26 04:50:47.224852
A date in the past: 2000-01-31 14:25:59
$

The calendar module provides a several data types and functions related to calendars.

    By default, these calendars have Monday as the first day of the week, and Sunday as the last (the European convention).

    The setfirstweekday() function can be used to set the first day of the week to any other weekday.

The example on the next page demonstrates the various data types and functions in the calendar module.

calendars.py

#!/usr/bin/env python3
import calendar as cal     # Note the use of "import as"


def main():
    cal.setfirstweekday(cal.SUNDAY)
    datasets = [cal.day_name, cal.day_abbr, cal.month_name, cal.month_abbr]
    for calendar_data in datasets:
        print(list(calendar_data))

    print(cal.month(2016, 1))  # Calendar for January 2016
    cal.prmonth(2017, 3, w=5)  # Calendar for March 2017


if __name__ == "__main__":
    main()

The output of the above program is shown next.

$ python3 calendars.py
['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
['', 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
['', 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']
    January 2016
Su Mo Tu We Th Fr Sa
                1  2
 3  4  5  6  7  8  9
10 11 12 13 14 15 16
17 18 19 20 21 22 23
24 25 26 27 28 29 30
31

                March 2017
 Sun   Mon   Tue   Wed   Thu   Fri   Sat
                     1     2     3     4
   5     6     7     8     9    10    11
  12    13    14    15    16    17    18
  19    20    21    22    23    24    25
  26    27    28    29    30    31

$

The time module contains various time-related functions and data types.

    Some of these functions refer to an epoch time, which is defined as hour zero on January 1st, 1970 for most systems.

Some of the available functions available in the time module are explained below.

    time.time() returns the time in seconds since the epoch as a floating point number.

    time.ctime([secs]) returns a time expressed in seconds since the epoch as a string.

        If the optional secs parameter is not passed as an argument it defaults to the current time.

    time.sleep(secs) suspends execution of the program for the given number of seconds.

        The argument may be a floating point number to indicate a more precise sleep time.

        The actual suspension time may be more or less than that requested because of a caught signal terminating the sleep() or the scheduling of other activities in the system.

    time.perf_counter() returns the value (in fractional seconds) of a performance counter (i.e. a clock with the highest available resolution to measure a short duration).

        It includes time elapsed during sleep and is system-wide.

    time.process_time() returns the value (in fractional seconds) of the sum of the system and user CPU time of the current process.

        It does not include time elapsed during sleep.

        The reference point of the returned value for both functions is undefined, so that only the difference between the results of consecutive calls is valid.

    time.strftime(format[,t]) converts a struct_time object t, or the current time if t is not provided, to a string as specified by the format argument.

References

The following URL provides a complete syntax for the format string: https://docs.python.org/3/library/time.html#time.strftime

    time.localtime([secs]) returns an object of type time.struct_time.

        If the optional secs parameter is not passed as an argument it defaults to the current time.

    The time.struct_time object is an object with a named tuple interface.

        The values can be accessed either by index or by attribute name.

The table on the following page lists the values that are available from the struct_time object.

Table 5.1. struct_time Properties and Values
Index	Attribute Name	Values
0 	tm_year 	for example 2016
1 	tm_mon 	Range from 1 to 12
2 	tm_mday 	Range from 1 to 31
3 	tm_hour 	Range from 0 to 23
4 	tm_min 	Range from 0 to 59
5 	tm_sec 	Range from 0 to 61
6 	tm_wday 	Range from 0 to 6 (Monday is 0)
7 	tm_yday 	Range from 1 to 366
8 	tm_isdst 	0 (no), 1 (yes), -1 (unknown)
N/A 	tm_zone 	abbreviation of time zone name
N/A 	tm_gmtoff 	offset east of UTC in seconds

The following program demonstrates the various functions from the time module.

time_testing.py

#!/usr/bin/env python3
import time


def counters():
    return(time.perf_counter(), time.process_time())


def main():
    starts = counters()
    print("time.time():", time.time())
    print("time.ctime():", time.ctime())
    print()
    now = time.localtime()
    f = "{0}/{1}/{2}"
    # struct_time values by property
    print("struct_time values by property and index")
    print(f.format(now.tm_mon, now.tm_mday, now.tm_year))

    # struct_time values by tuple index
    print(f.format(now[1], now[2], now[0]))
    print()
    # Formatting of struct_time objects
    print("time.strftime() examples:")
    print("Format: %m/%d/%Y\tResult: ",
          time.strftime("%m/%d/%Y", now))
    print("Format: %A %B %d\tResult: ",
          time.strftime("%A %B %d", now))
    print()
    time.sleep(5)
    ends = counters()
    print()
    print("Performance:", ends[0] - starts[0], "seconds")
    print("Process:", ends[1] - starts[1], "seconds")


if __name__ == "__main__":
    main()

The output of the above program is shown on the following page.

$ python3 time_testing.py
time.time(): 1575657424.6517038
time.ctime(): Fri Dec  6 13:37:04 2019

struct_time values by property and index
12/6/2019
12/6/2019

time.strftime() examples:
Format: %m/%d/%Y	Result:  12/06/2019
Format: %A %B %d	Result:  Friday December 06


Performance: 5.003588916002627 seconds
Process: 0.00015263399999999872 seconds
$

Exercises

The solution files for these exercises are in the AD141-apps repository, within the modules/solutions directory.
Exercise 1

Define a few functions and place them in a module.

    Now, write a Python program in a separate file that imports the module and calls the functions.

Exercise 2

Create a new file and define a function in it with the same name (but different behavior) as one of the functions from the previous exercise.

    In a separate file, create an application that imports the module from this exercise that contains the function and the module from the previous exercise.

        The application should be able to successfully call all of the functions from both of the imported modules.

Exercise 3

Write a program that sorts its command line arguments.
Exercise 4

Write a program that sums the command line arguments.

    The program should print both the sum of the arguments and the average value.

References

    The modules available from the Python standard library, and their documentation, can be found at the following URL: https://docs.python.org/3/library/index.html

    The PyPi repository can be found at the following URL: https://pypi.python.org/pypi

    The sys module's complete list of properties and functions and their documentation can be found at the following URL: https://docs.python.org/3/library/sys.html

    Many of the standard modules that deal with numbers and math can be found in the Python documentation at the following URL: https://docs.python.org/3/library/numeric.html

    The following URL provides a complete lst of data types provided by the datetime module: https://docs.python.org/3/library/datetime.html

    The following URL provides a complete syntax for the format string: https://docs.python.org/3/library/time.html#time.strftime 