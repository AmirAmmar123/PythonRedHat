Chapter 6.  Classes in Python

Classes in Python
Summary

Abstract

Goal 	

Apply object oriented programming principles by using classes.
Objectives 	

    Understand the basic principles of an object oriented programming language.

    Use the class keyword to define custom data types.

    Use properties and decorators as a Pythonic way of writing classes.

    Use Python's special methods within a class definition to accomplish standard tasks.

    Use class variables as a way of providing shared access to instances of a class.

    Understand inheritance and polymorphism to take simplify class creation.

    Use various built-in functions to obtain information about the relationship between data types.

Sections 	

    Classes in Python

Classes in Python
Objectives

    Understand the basic principles of an object oriented programming language.

    Use the class keyword to define custom data types.

    Use properties and decorators as a Pythonic way of writing classes.

    Use Python's special methods within a class definition to accomplish standard tasks.

    Use class variables as a way of providing shared access to instances of a class.

    Understand inheritance and polymorphism to take simplify class creation.

    Use various built-in functions to obtain information about the relationship between data types.

Principles of Object Orientation

Object-oriented programming is a style of programming that lends itself to the principle that a software solution should closely model the problem domain.

    If your problem domain was banking, then some data types in your program might be Customer, Account, and Loan.

    If your problem domain was system software, then you might require types such as Process or File.

The aforementioned types would give rise to objects (entities) characterized by the following properties:

    Behavior: The actions the objects can perform.

    Attributes: The characteristics or properties of each object.

Object Orientation is characterized by the following principles:

    Encapsulation: The coupling of data and methods.

    Data abstraction or information hiding: Access to private data is achieved via a public interface (public accessor methods of the class).

    Inheritance: The derivation of specific data types from more general types. A typical object-oriented system contains inheritance hierarchies.

    Polymorphism: In an inheritance hierarchy, there may be a set of classes, each with the same named methods and interfaces, but whose implementations are different. Polymorphism is the ability of a language to differentiate these same named methods at run time.

Defining New Data Types

For domain specific problems, Python permits the defining of custom data types.

    These new data types are defined by using the class keyword.

Once a new data type has been defined, programmers can create instances of them.

    Each instance of a data type is called an object.

Suppose a new data type representing a student is desired.

    A minimal Student data type would be defined with a class definition such as the one below.

student0.py

#!/usr/bin/env python3
""" This module defines a Student datatype and a main function to demonstrate
    the instantiation of a Student object """


class Student:
    """ This class represents a Student. This mulitline string will act as
    a doc string since it is declared at the top of the class"""


def main():
    """ This main is basically for testing purposes only.
    The Student class would typically be imported by
    another module as opposed to running it here."""

    jeff = Student()     # Instantiate a Student object
    heather = Student()  # Instantiate another Student
    print(jeff, id(jeff), hex(id(jeff)))
    print(heather, id(heather), hex(id(heather)))


if __name__ == "__main__":
    main()

In the preceding example, the code is documented in three places:

    The module is being documented

    The class is being documented

    The main() function is being documented

The following example shows how you can get the documentation from the previous module by using the help function.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> help('student0')

The preceding execution of the help function shows the following information:

Help on module student0:

NAME
    student0

DESCRIPTION
    This module defines a Student data type and a main function to demonstrate
    the instantiation of a Student object

CLASSES
    builtins.object
        Student

    class Student(builtins.object)
     |  This class represents a Student. This multiline string will act as
     |  a doc string since it is declared at the top of the class
     |
     |  Data descriptors defined here:
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)

FUNCTIONS
    main()
        This main is basically for testing purposes only.
        The Student class would typically be imported by
        another module as opposed to running it here.
:

The execution output of the preceding program might be as follows:

$ python3 student0.py
<__main__.Student object at 0x7f613b7fca90> 140055586785936 0x7f613b7fca90
<__main__.Student object at 0x7f613b8027f0> 140055586809840 0x7f613b8027f0
$

Ultimately, the class definition will contain many methods, the collection of which defines the behavior for the class.

    Currently, the Student objects created in the example are skeletal because there are no custom properties or methods within them.

        When designing software, there would typically be an analysis and design phase before any coding was undertaken.

        In that phase, the behavior and the attributes of class objects would be determined by the designers.

Student attributes will consist of a name and a major.

    It would be convenient to pass these attributes as parameters during the creation of a Student object.

jeff = Student("Jeff", "American History")
heather = Student("Heather", "Mathematics")

When an object is created in Python, a special method called __init__() is called.

    Therefore, the Student class can include this special method.

        In this case, two explicit arguments are passed to the method.

        However, Python always also implicitly passes a reference to the object being constructed as the first parameter to the method.

    The declaration of the __init__() method might begin like the following:

def __init__(self, name, major):
    pass # Remember to put real code here

    The pass statement does nothing, but is used here to satisfy the syntax requirement for a method.

We still need to add some code to fill the object with its data.

student1.py

#!/usr/bin/env python3
class Student:

    def __init__(self, name, major):
        self.name = name
        self.major = major


def main():
    jeff = Student("Jeff", "American History")
    heather = Student("Heather", "Mathematics")
    print(jeff.name, ":", jeff.major)
    print(heather.name, ":", heather.major)
    jeff.name = "Jeffrey"
    heather.major = "Computer Science"
    print(jeff.name, ":", jeff.major)
    print(heather.name, ":", heather.major)


if __name__ == "__main__":
    main()

    The first parameter in the __init__() method is called self.

        This is a reference to the object being created.

        While this variable could technically be called anything, traditionally it is called self.

    The __init__() method can be seen as a constructor of the object.

        Its typical role is to copy the parameters to the object's data.

        self.name and self.major are used to store the local variables name and major as instance data of the object.

    The application accesses the properties of the object directly in the main function.

        The print statements access the value of the properties directly.

        jeff.name = "Jeffrey" shows how to set properties directly.

Typically, a class would have methods to retrieve and modify the instance data.

    Many object-oriented languages emphasize data hiding, where direct access to the data is private.

        Public access to the variables is then typically provided in the form of methods typically referred to as getters and setters for the data.

        While Python has no concept of private, any symbol that starts with a single underscore is understood to be private by convention only.

    The following example shows an updated version of the Student class that includes instance methods that have been added to the class.

student2.py

#!/usr/bin/env python3
class Student:
    def __init__(self, name, major):
        self._name = name
        self._major = major

    def get_name(self):
        return self._name

    def set_name(self, name):
        self._name = name

    def get_major(self):
        return self._major

    def set_major(self, major):
        self._major = major


def main():
    jeff = Student("Jeff", "American History")
    print(jeff.get_name(), ":", jeff.get_major())
    jeff.set_name("Jeffrey")
    print(jeff.get_name(), ":", jeff.get_major())


if __name__ == "__main__":
    main()

The @property Decorator

The preceding example uses getter and setter methods. This is a common convention in many object-oriented languages to manage how class attributes are accessed and mutated.

In Python, however, the recommended, Pythonic, way to implement a getter/setter mechanism is to use the @property decorator to wrap class attributes.
Decorators

Python decorators are a built-in feature of the language and extend the behavior of functions, classes, and methods.

    Decorators wrap existing functions, or classes, to extend their original functionality.

    You can define decorators as functions or classes that take another function, or class, extend its behavior, and return the decorated function/class.

    After creating a decorator, you can use it to decorate functions or classes by using the name of the decorator, preceded by the @ symbol, just before the function/class definition.

Using the @property Decorator

Although you can create your own decorators, Python comes with a number of built-in decorators, such as the @property decorator.

    A class property is a method that can be accessed as an attribute. The value of the attribute is the return value of the method.

    The following example demonstrates the use of the built-in @property decorator to define getter methods for the _name and _major attributes of a student.

    The _name and _major attributes are not meant to be accessed from outside the class.

    Using the @property decorator creates a new property. The property name is the name of the method that @property decorates. In the following example, the def name (self) method signature defines a new property called name.

    The implementation of the @property-decorated method is the getter of the property. In the example, the name property getter returns the value of self._name.

    Properties include a setter attribute that you can use to define a setter method.

    To define a setter method on a property, use the @property-name.setter decorator. For a setter method to be valid, you must use the same method name as in the getter method. The following example demonstrates defining setters by using the @name.setter and @major.setter decorators.

student3.py

#!/usr/bin/env python3
class Student:

    def __init__(self, name, major):
        self.name = name    # Calls the @name.setter method
        self.major = major  # Calls the @major.setter method

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        # print("Debug:", "name setter being called")
        self._name = name

    @property
    def major(self):
        return self._major

    @major.setter
    def major(self, major):
        # print("Debug:", "major setter being called")
        self._major = major

The following example shows how to use the preceding module.

student3_test.py

#!/usr/bin/env python3
from student3 import Student


def main():
    jeff = Student("Jeff", "American History")
    heather = Student("Heather", "Mathematics")
    print(jeff.name, ":", jeff.major)
    jeff.name = "Jeffrey"
    print(jeff.name, ":", jeff.major)
    heather.major = "Computer Science"
    print(heather.name, ":", heather.major)


if __name__ == "__main__":
    main()

    The following snippet is the output of the preceding example.

$ python3 student3_test.py
Jeff : American History
Jeffrey : American History
Heather : Computer Science
$

When you access a property as an attribute, e.g. jeff.name, you trigger the getter method of the property. Similarly, when you mutate a property, e.g. jeff.name = "Jeff", you trigger the setter method of the property.

    The added benefit is that if any business logic or validation of the properties needs to be performed on the properties, there are existing methods where the validation can be done.

    More information can be found by reading the documentation for the property class by typing help(property) in an interactive Python shell.

Special Methods

In addition to the __init__() method, there are other special methods that are commonly defined within a class.

    One such method is called __str__().

        This method is automatically invoked by the str(object) constructor and the built-in functions format() and print() to compute the nicely printable string representation of an object.

        The return value must be a string object.

    Another special method is called __del__().

        Called when the instance is about to be destroyed.

        The del statement del x doesn't directly call the x.__del__() method. The former decrements the reference count for x by one, and the latter is only called when x‘s reference count reaches zero.

        It is not guaranteed that __del__() methods are called for objects that still exist when the interpreter exits.

A class can also implement certain operations that are invoked by special syntax.

    This is done by defining methods with special names.

    This is Python's approach to operator overloading.

        For instance, if a class defines a method called __eq__(), and x is an instance of this class, then x == someobject invokes a call to the x.__eq__() method of the class and passes someobject as a parameter.

        Typically, any attempt to execute an operation will raise an AttributeError or TypeError exception when no corresponding method has been defined.

References

The list of special methods that can be defined inside a class can be found in the documentation here: http://docs.python.org/3/reference/datamodel.html#special-method-names

    The following example updates the preceding version of the Student class to include several special methods.

student4.py

#!/usr/bin/env python3
class Student:

    def __init__(self, name, major):
        self.name = name    # Calls the @name.setter method
        self.major = major  # Calls the @major.setter method

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, name):
        self._name = name

    @property
    def major(self):
        return self._major

    @major.setter
    def major(self, major):
        self._major = major

    def __str__(self):
        return "{} : {}".format(self.name, self.major)

    def __eq__(self, obj):
        if type(obj) != Student:
            return False
        else:
            return self.name == obj.name and \
                   self.major == obj.major

    The following example is an application that uses the preceding Student class.

student_test.py

#!/usr/bin/env python3
from student4 import Student


def main():
    s1 = Student("Elizabeth", "Electrical Engineering")
    s2 = Student("Robert", "Electrical Engineering")
    student_info("Before", s1, s2)
    s2.name = "Elizabeth"
    student_info("After", s1, s2)


def student_info(label, student1, student2):
    print(label)
    print(student1, "id=", id(student1))
    print(student2, "id=", id(student2))
    fmt = "{0} == {1} : {2}"
    print(fmt.format(student1, student2, student1 == student2))
    print()


if __name__ == "__main__":
    main()

    The execution output of the preceding application might be:

$ python3 student_test.py
Before
Elizabeth : Electrical Engineering id= 139687194554720
Robert : Electrical Engineering id= 139687194554776
Elizabeth : Electrical Engineering == Robert : Electrical Engineering : False

After
Elizabeth : Electrical Engineering id= 139687194554720
Elizabeth : Electrical Engineering id= 139687194554776
Elizabeth : Electrical Engineering == Elizabeth : Electrical Engineering: True
$

The following example defines a class called Fraction.

    Although Python already provides a class called Fraction in a module called fractions, a simplified version of the representation of a fraction is being presented here to show another example of creating a custom data type.

    A Fraction will be composed of an integer for the numerator and an integer for the denominator.

    The Fraction class also defines several special methods.

fraction.py

#!/usr/bin/env python3
class Fraction:
    def __init__(self, numerator=0, denominator=1):
        self.numerator = numerator
        self.denominator = denominator

    def __str__(self):
        return "{}/{}".format(self.numerator, self.denominator)

    def __lt__(self, other):
        left = self.numerator / self.denominator
        right = other.numerator / other.denominator
        return left < right

    def __mul__(self, other):
        numerator = self.numerator * other.numerator
        denominator = self.denominator * other.denominator
        return Fraction(numerator, denominator)

An application that uses the preceding Fraction class, and the output of the application are as follows:

fraction_tests.py

#!/usr/bin/env python3
from fraction import Fraction


def main():
    fractions = [Fraction(1, 3), Fraction(), Fraction(3, 4)]
    for fraction in fractions:
        print(fraction)

    frac_1_3, frac_0_1, frac_3_4 = fractions
    print(frac_1_3, "<", frac_0_1, ":", frac_1_3 < frac_0_1)  # False
    print(frac_1_3, "<", frac_3_4, ":", frac_1_3 < frac_3_4)  # True
    result = frac_1_3 * frac_3_4
    print(frac_1_3, "*", frac_3_4, "=", result)  # 1/3 * 3/4 = 3/12


if __name__ == "__main__":
    main()

$ python3 fraction_tests.py
1/3
0/1
3/4
1/3 < 0/1 : False
1/3 < 3/4 : True
1/3 * 3/4 = 3/12
$

Class Variables

Class data is a part of the class but not a part of an object.

    Instance variables are typically for data unique to each instance, while class variables are for attributes and methods shared by all instances of the class.

The following example defines a class variable called quantity.

car.py

#!/usr/bin/env python3
class Car:

    quantity = 0  # Class variable shared by all instances

    def __init__(self, make, model):
        self.make = make
        self.model = model
        self.odometer = 0
        Car.quantity += 1

    def __del__(self):
        Car.quantity -= 1

    def drive(self, miles):
        self.odometer += miles

    def __str__(self):
        data = [self.make, self.model, " ~ Odometer:", str(self.odometer)]
        return " ".join(data)

The following application shows the differences between accessing instance variables and class variables from the Car class.

car_test.py

#!/usr/bin/env python3
from car import Car


def main():
    malibu = Car("Chevy", "Malibu")
    miata = Car("Mazda", "Miata")
    mustang = Car("Ford", "Mustang")
    soul = Car("Kia", "Soul")
    print("# of existing Cars:", Car.quantity)

    malibu.drive(miles=10000)
    miata.drive(500)
    print(malibu, miata, mustang, soul, sep="\n")
    print("Deleting Malibu")
    del malibu

    print("# of existing Cars:", Car.quantity)


if __name__ == "__main__":
    main()

    Note the difference in the syntax between accessing instance variables and accessing class variable.

    Each object of type Car has its own make, model, and odometer properties.

    All Car objects have access to the single quantity variable that exists in memory.

Inheritance

Inheritance is one of the signature characteristics of object-oriented programming.

    In designing a set of classes that is important to a set of applications, there will usually be some classes that are related to one another.

    One kind of relationship, known as inheritance, is described by the words "is a".

        A Manager is an Employee.

        A Directory is a File.

        A Square is a Shape.

        An Array is a Data Structure.

The main idea behind inheritance is that the data and methods of the superclass (the base class) are directly reused by a subclass (the derived class).

    For example, a Directory object could directly reuse File methods since a Directory is a File.

    The subclass may add newly created methods to implement additional behavior.

The syntax for defining the inheritance is as follows:

class SubClassName(SuperClassName)

    The following example demonstrates inheritance by defining a subclass called GradStudent class that has the Student class as its superclass.

    The GradStudent is a Student that receives a monetary stipend.

    The inheritance is implemented with the following syntax:

class GradStudent(Student):

    The GradStudent class will inherit all the attributes and methods of Student.

gradstudent.py

#!/usr/bin/env python3
from student4 import Student


class GradStudent(Student):

    def __init__(self, name, major, stipend):
        # Pass the name and major to the __init__() of the
        # super class then store the part specific to the
        # GradStudent object
        super().__init__(name, major)
        self.stipend = stipend

    @property
    def stipend(self):
        return self._stipend

    @stipend.setter
    def stipend(self, stipend):
        self._stipend = stipend

    def __str__(self):
        # Override the __str__ from the parent class by
        # first getting the parent information:
        # super().__str__()
        # and then concatenating the stipend
        return "{} {}".format(super().__str__(), self.stipend)

The __init__() method of the GradStudent class uses super() to pass information to the __init__() method of the Student class.

    super() returns an object that acts as a proxy, and delegates method calls to a parent or sibling class.

    This is useful for accessing inherited methods that have been overridden in a class.

The __str__() method of the GradStudent class overrides the __str__() method of the Student class.

    The method reuses the parent classes __str__() method with a call to super() and incorporates it into its own.

gradstudent_test.py

#!/usr/bin/env python3
from gradstudent import GradStudent


def main():
    grad_student = GradStudent("James", "Anthropology", 25000)

    print("  MAJOR:", grad_student.major)
    print("   NAME:", grad_student.name)
    print("STIPEND:", grad_student.stipend)
    print(grad_student)


if __name__ == "__main__":
    main()

    The output of the preceding program is as follows:

$ python3 gradstudent_test.py
  MAJOR: Anthropology
   NAME: James
STIPEND: 25000
James : Anthropology 25000
$

Polymorphism

The word polymorphism literally means "many forms".

    When the word is used in object-oriented programming languages, it means the ability of the language to execute a method based on the run time type of a variable.

For example, suppose we have a Shape class with derived classes called Square, Rectangle and Circle.

    It would be simple enough to create objects of these subclasses.

s1 = Square()
c1 = Circle()
r1 = Rectangle()

    Suppose further that each of the subclasses has an area() method.

    Each subclass would need to have its own implementation of the area() method since it is dependent upon the specific subclass of Shape.

    A collection of various shapes can then be created in a list.

shapes = [ s1, c1, r1 ]

    Iterating over the list of shapes to calculate the area of each could then be done as follows.

for shape in shapes:
    print(shape.area())

    Polymorphism ensures that it is the runtime type of the object whose method will be called.

    Python knows the run time type of each Shape object and calls the appropriate area() method.

    The entire code to implement the preceding example is as follows:

shape.py

#!/usr/bin/env python3
class Shape:
    id = 100

    def __init__(self, name):
        self.name = name
        self.number = Shape.id
        Shape.id += 1

    def area(self):
        pass  # Intended to be implemented by subclasses

    @property
    def name(self): return self._name

    @name.setter
    def name(self, name): self._name = name

    def __str__(self):
        return "Name:{}  id:{}".format(self.name, self.number)

shape_circle.py

#!/usr/bin/env python3
import math
from shape import Shape


class Circle(Shape):
    def __init__(self, name, radius):
        super().__init__(name)
        self.radius = radius

    def __str__(self):
        fmt = "{}  Radius:{}"
        return fmt.format(super().__str__(), self.radius)

    def area(self):
        return math.pi * self.radius ** 2

shape_rectangle.py

#!/usr/bin/env python3
from shape import Shape


class Rectangle(Shape):
    def __init__(self, name, length, width):
        super().__init__(name)
        self.length = length
        self.width = width

    def __str__(self):
        fmt = "{}  Length:{} Width:{}"
        return fmt.format(super().__str__(), self.length,
                          self.width)

    def area(self):
        return self.length * self.width

shape_square.py

#!/usr/bin/env python3
from shape_rectangle import Rectangle


class Square(Rectangle):
    def __init__(self, name, length):
        super().__init__(name, length, length)

In inheritance hierarchies like the Shape hierarchy, one can conceive of two kinds of methods.

    Those with behavior invariant over specialization.

        The getter and setter methods for the name attribute are such methods and, therefore, there is no need to override them in the subclasses.

    Those with behavior that varies over specialization.

        The area() method is such a method and, therefore, it is overridden in the subclasses.

The following application tests all the classes in the Shape hierarchy.

shape_testing.py

#!/usr/bin/env python3
from shape_circle import Circle
from shape_square import Square
from shape_rectangle import Rectangle


def main():
    shapes = [Circle("Circle 1", 10),
              Square("Square 1", 5),
              Rectangle("Rectang1e 1", 5, 10)]

    for shape in shapes:
        print(shape)
        print("AREA:", shape.area())
        print("*" * 50)


if __name__ == "__main__":
    main()

    The output of this program might be as follows:

$ python3 shape_testing.py
Name:Circle 1 id:100 Radius:10
AREA: 314.1592653589793
**************************************************
Name:Square 1 id:101 Length:5 Width:5
AREA: 25
**************************************************
Name:Rectang1e 1 id:102 Length:5 Width:10
AREA: 50
**************************************************
$

Type Identification

The type function, which identifies the type of a variable has already been used in examples several times.

    On some occasions, there is the requirement to determine whether an object is of one class or another.

    The isinstance() function determines whether a particular object is of a particular class.

    The issubclass() function determines whether one class is a subclass (direct or otherwise) of another class.

classes.py

#!/usr/bin/env python3
class Employee:
    pass


class Manager(Employee):
    pass


class Executive(Manager):
    pass


def main():
    manager = Manager()

    print(isinstance(manager, Employee))      # True
    print(isinstance(manager, Manager))       # True
    print(isinstance(manager, Executive))     # False

    print(issubclass(Executive, Executive))   # True
    print(issubclass(Executive, Manager))     # True
    print(issubclass(Executive, Employee))    # True
    print(issubclass(Executive, object))      # True


if __name__ == "__main__":
    main()

Exercises

The solution files for these exercises are in the AD141-apps repository, within the classes/solutions directory.
Exercise 1

Create a class called Person.

    Each Person should have a name, an age, and a gender.

    In addition to getters and setters for the above methods, the Person class must have an __init__() method and a __str__() method.

    The __init__() and __str__() methods must be defined such that the following can be tested inside of an application.

p1 = Person("Michael", 45, "M")
print(p1)

Exercise 2

Create a class called Family.

    The Family does not extend Person but rather must be composed of two Person objects representing the parents and a list of Person objects representing the children.

    Therefore, the __init__() method must take two required parameters (the parents), followed by a variable number of arguments (the children).

    The following files are available in the AD141-apps repository, within the classes/starter directory, and you can use them in the exercise:

family_test.py

#!/usr/bin/env python3


def main():
    mother = Person("Mom", 45, "F")
    father = Person("Dad", 45, "M")
    kid1 = Person("Johnie", 2, "M")
    kid2 = Person("Janie", 3, "F")
    myFamily = Family(mother, father, kid1, kid2)
    kid3 = Person("Paulie", 1, "M")
    myFamily.add(kid3)
    print(myFamily)


if __name__ == "__main__":
    main()

    Note the add method in the Family class.

Exercise 3

Implement the necessary special methods so that the <, ==, and > operators can be used with Family objects.

    The criteria for the methods should be the number of children.

    The following code could be used to test the methods:

myFamily = Family(mom, dad, kid1, kid2)
smiths = Family(mom, dad, kid1)
if (myFamily > smiths):
    print("we have more kids than smiths")
if (myFamily == smiths):
    print("families have same # of kids")
if (myFamily < smiths):
    print("we have fewer kids than smiths")

Exercise 4

Implement the following class hierarchy.

    Define a Worker class with a name, a salary, and number of years worked.

        Provide a method called pension that returns an amount equal to the years worked times 10% of the salary.

        Implement a name() method in the Worker class and have this be a default method for all derived classes.

    Derive Manager from Worker.

        A manager's pension is defined by the number of years worked times 20% of the salary.

    Derive Executive from Manager.

        An executive's pension is defined by the number of years worked times 30% of the salary.

References

The list of special methods that can be defined inside a class can be found in the documentation here: http://docs.python.org/3/reference/datamodel.html#special-method-names 