Generators

While list and dictionary comprehensions are concise ways of creating their respective data types, they require that the entire structure be created in memory before being available for use.

    If the amount of data is huge, then it requires a lot of memory.

    If the amount of data is infinite, then their use becomes impossible.

Generators are often used in situations where a lot of data needs to be generated without the overhead of storage of the entire dataset.

    Generators are a special class of functions that simplify the task of writing iterators.

    Any function containing a yield keyword is a generator function.

        On reaching a yield, the generator's state of execution is suspended and local variables are preserved.

        On the next call to the generator's next() method, the function will resume executing.

Here is a simple example of a generator function.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> def generate_odds(upper_limit):
...     for odd in range(1, upper_limit, 2):
...          yield odd
...
>>> odds = generate_odds(5)
>>> print(type(odds))
<class 'generator'>
>>> next(odds)
1
>>> next(odds)
3
>>> next(odds)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> quit()
$

As seen in the output on the previous example; if the next() function is called too many times for a given generator object, a StopIteration exception is raised.

Since a generator acts as an iterator, it can be used with a for loop.

    The benefit of this is that the for loop automatically calls the next() function and silently handles the StopIteration exception.

        This can be seen in the following example.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> def generate_odds(upper_limit):
...     for odd in range(1, upper_limit, 2):
...         yield odd
...
>>> for val in generate_odds(5):
...     print(val, end=" ")
...
1 3
>>> exit()
$