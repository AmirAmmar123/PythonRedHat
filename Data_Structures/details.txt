Chapter 9.  Data Structures

Data Structures
Summary

Abstract

Goal 	

Use compact syntax and specialized statements to create, process, and sort data structures.
Objectives 	

    Use list comprehensions as an alternative and concise way of creating lists.

    Use dictionary comprehensions as an alternative and concise way of creating dictionaries.

    Understand and use generators to retrieve large amounts of data without the overhead of storing the data.

    Use generator expressions as an alternative and concise way of creating generators.

    Use the zip datatype to process parallel collections.

Sections 	

    Data Structures

Data Structures
Objectives

    Use list comprehensions as an alternative and concise way of creating lists.

    Use dictionary comprehensions as an alternative and concise way of creating dictionaries.

    Understand and use generators to retrieve large amounts of data without the overhead of storing the data.

    Use generator expressions as an alternative and concise way of creating generators.

    Use the zip datatype to process parallel collections.

List Comprehensions

    List comprehensions provide a concise way of creating a list.

    Each list comprehension consists of square brackets [] containing an expression followed by a for clause, then zero or more for or if clauses.

    The result is a list obtained from evaluating the expression in the context of the for and if clauses that follow it.

    When the expression is placed inside parentheses (), each member of the resulting list is a tuple.

    The following example uses the interactive Python shell to demonstrate creating several list comprehensions.

list_comprehensions.py

#!/usr/bin/env python3
def main():
    sample = [hex(x) for x in range(0, 16)]
    print(type(sample), sample, sep="\t")
    print([(x, x * x) for x in range(2, 7)])
    print([x * x for x in range(1, 16) if x % 2 == 0])


if __name__ == '__main__':
    main()

The execution output of the preceding program might be as follows:

$ python3 list_comprehensions.py
<class 'list'>  ['0x0', '0x1', '0x2', '0x3', '0x4', '0x5', '0x6', '0x7', '0x8', '0x9', '0xa', '0xb', '0xc', '0xd', '0xe', '0xf']
[(2, 4), (3, 9), (4, 16), (5, 25), (6, 36)]
[4, 16, 36, 64, 100, 144, 196]
$

    The following snippet includes more examples of list comprehensions:

triples.py

#!/usr/bin/env python3
def main():
    alist = [2, 4, 6]
    print([3 * x for x in alist])
    print([3 * x for x in [1, 2, 3, 4, 5]])
    print([3 * x for x in range(1, 5)])
    print([[x, 3 * x] for x in range(1, 5)])


if __name__ == "__main__":
    main()

The following example shows a function being applied to each element of a list.

from_functions.py

#!/usr/bin/env python3
def main():
    names = ["Ashley", "Emma", "Jayden", "Ethan"]
    print([len(name) for name in names])
    print([[name, len(name)] for name in names])
    grades = [[88, 77, 99], [95, 98, 97], [79, 100, 95]]
    highest = [max(grade) for grade in grades]
    print(highest)


if __name__ == "__main__":
    main()

The execution output of the preceding program might be as follows:

$ python3 from_functions.py
[6, 4, 6, 5]
[['Ashley', 6], ['Emma', 4], ['Jayden', 6], ['Ethan', 5]]
[99, 98, 100]
$

A list comprehension can have an if clause to act as a filter.

palindromes.py

#!/usr/bin/env python3
def main():
    words = ["hello", "racecar", "eye", "bike", "stats", "civic"]
    palindromes = [x for x in words if x[::-1] == x]
    print(palindromes)


if __name__ == "__main__":
    main()

The execution output of the preceding program might be as follows:

$ python3 palindromes.py
['racecar', 'eye', 'stats', 'civic']
$

Dictionary Comprehensions

A dictionary comprehension is similar to a list comprehension, but it constructs a dict object instead of a list.

The syntax of a dictionary comprehension has two main differences:

    It is enclosed in curly braces {} instead of square brackets.

    It contains two expressions, separated by a colon :.

        The expression before the colon is the dictionary key.

        The expression after the colon is the dictionary value.

dictionary_comprehension.py

#!/usr/bin/env python3
def main():
    names = ["Ashley", "Emma", "Jayden", "Ethan"]
    print({name: len(name) for name in names})


if __name__ == "__main__":
    main()   # Output: {'Jayden': 6, 'Ethan': 5, 'Ashley': 6, 'Emma': 4}

The following example maps the names of a file to its sizes for each file in the current directory.

fileinfo.py

#!/usr/bin/env python3
import os


def main():
    files = os.listdir(".")
    fileinfo = {f: os.path.getsize(f) for f in files}
    for name, size in fileinfo.items():
        print("{0:30} : {1:>6,} bytes".format(name, size))


if __name__ == "__main__":
    main()

Dictionaries with Compound Values

The following example is more complex and uses both list and dictionary comprehensions.

    The example creates a dictionary of customers where the value is a list of all the customer information.

    The example uses the data from the customers.txt file.

    A portion of the comma separated file is shown below.

customers.txt

Alice,Young,1 Main St,Carrington,ND,58421
Amanda,Wright,103 Center St,Mannington,WV,26582
Amy,Martinez,1108 Sheller Ave,Paden City,WV,26159
Andrew,Miller,113 Mountain Village Rd Apt B,New Rockford,ND,58356
Angela,Mitchell,119 W Court St,Veedersburg,IN,47987
Ann,Moore,12 34th St,Berlin,MD,21811
Anna,Morris,1209 7th St Ne,Chambersburg,PA,17201
Anthony,Nelson,1251 Hagan Dr,Evanston,WY,82930
Barbara,Parker,127 Franklin St,Goldendale,WA,98620
Betty,Perez,127 S Wood St,Ocean City,MD,21842
Brenda,Phillips,1300 N Yorktown Dr,Devils Lake,ND,58301
Brian,Reed,134 Adams St,Ashdown,AZ,71822
Carl,Roberts,1411 Us Highway 59 S,Lyman,WY,82937
Carol,Robinson,1600 N Hervey,Bedford,PA,15522
Edward,Harris,406 S Jackson Ave,Fowler,IN,47944
Christine,Scott,1807 W Pike St Ste B,Hope,AZ,71801
Christopher,Smith,1918 Mercersburg Rd,Juneau,AK,99801
Cynthia,Stewart,212 Laurel St,Prescott,AZ,71857
Daniel,Taylor,225 Lincoln Way W,Kemmerer,WY,83101
David,Thomas,815 Hill Ave,Clarksburg,WV,26301
Deborah,Thompson,800 Booth St,Greencastle,PA,17225
Jennifer,Turner,746 Saint Andrews Blvd,Texarkana,AZ,71854
Jeffrey,Walker,715 N 42nd St,Mc Connellsburg,PA,17233
Jason,White,6100 E Rio Grande Ave,Newport,IN,47966
Janet,Williams,607 Waynetown Rd,Mercersburg,PA,17236
James,Wilson,537 10th St,Grand Forks,ND,58201
Henry,Martin,524 N Lincoln,Toppenish,WA,98948
Douglas,Hall,400 Se Lincoln Rd,Bloomington,IN,47404
Dorothy,Green,3880 E 3rd St,Yakima,WA,98908
Donna,Gonzalez,3375 Koapaka St Suite 250,Clinton,IN,47842
Donald,Garcia,330 Boise St,Defuniak Springs,FL,32435
Diane,Evans,3142 Tyler Hwy,Charleston,SC,29407

The example is broken down into the following five function calls to more clearly delineate each step of the process.

    The get_customers() function reads from the text file and returns it as a nested list.

    The get_info() function returns information about the nested list, basically for informational purposes.

    The get_dictionary() function is where the nested list is converted into a dictionary, using a dictionary comprehension, and returned.

    The print_customers() function prints out all the customer names (the keys) of the resulting dictionary.

    The user_interaction() function gets a customer name from the user and prints the value associated with that key.

The module that defines all the preceding functions is as follows:

customer_functions.py

#!/usr/bin/env python3
def get_customers():
    with open("customers.txt", "r") as thefile:
        customer_list = thefile.readlines()
    # use a list comprehension to convert to a
    # nested list of lists (each a list of strings)
    return [customer.rstrip().split(",") for customer in customer_list]


def get_info(customers):
    print("Nested Structure:", type(customers),
          type(customers[0]), type(customers[0][0]))
    # partial contents of customers
    print(customers[0], customers[1], sep="\n", end="\n\n")


def get_dictionary(customers):
    # Convert to dictionary using a dictionary comprehension
    return {"{} {}".format(cust[0], cust[1]): cust for cust in customers}


def print_customernames(customer_names):
    print("Customer names:")
    for i, name in enumerate(customer_names):
        print("{0:20}".format(name), end="|")
        if i % 4 == 3:
            print()
    print("\n")


def user_interaction(customers):
    tags = ["FirstName", "LastName", "Street", "City", "State", "ZipCode"]
    fmt = "{:16}{:16}{:20}{:16}{:6}{:5}"
    while True:
        name = input("Enter a name (or 'quit' to quit):")
        if name == "quit":
            break
        data = customers.get(name)
        if data:
            print(fmt.format(*tags))
            print(fmt.format(*data))

An application that calls all the preceding functions is as follows:

customers.py

#!/usr/bin/env python3
import customer_functions


def main():
    customer_list = customer_functions.get_customers()
    customer_functions.get_info(customer_list)
    customer_map = customer_functions.get_dictionary(customer_list)
    customer_functions.print_customernames(customer_map.keys())
    customer_functions.user_interaction(customer_map)


if __name__ == "__main__":
    main()

The execution output of the preceding program might be as follows:

$ python3 customers.py
Nested Structure: <class 'list'> <class 'list'> <class 'str'>
['Alice', 'Young', '1 Main St', 'Carrington', 'ND', '58421']
['Amanda', 'Wright', '103 Center St', 'Mannington', 'WV', '26582']

Customer names:
Alice Young         |Amanda Wright       |Amy Martinez        |Andrew Miller       |
Angela Mitchell     |Ann Moore           |Anna Morris         |Anthony Nelson      |
Barbara Parker      |Betty Perez         |Brenda Phillips     |Brian Reed          |
Carl Roberts        |Carol Robinson      |Edward Harris       |Christine Scott     |
Christopher Smith   |Cynthia Stewart     |Daniel Taylor       |David Thomas        |
Deborah Thompson    |Jennifer Turner     |Jeffrey Walker      |Jason White         |
Janet Williams      |James Wilson        |Henry Martin        |Douglas Hall        |
Dorothy Green       |Donna Gonzalez      |Donald Garcia       |Diane Evans         |
Dennis Edwards      |Debra Davis         |Jerry Cook          |Jessica Collins     |
John Clark          |Alicia Reed         |

Enter a name (or 'quit' to quit):Alice Young
FirstName       LastName        Street              City            State ZipCode
Alice           Young           1 Main St           Carrington      ND    58421
Enter a name (or 'quit' to quit):Jessica Collins
FirstName       LastName        Street              City            State ZipCode
Jessica         Collins         300 E 1st N         Burlington      CO    80807
Enter a name (or 'quit' to quit):quit
$

Generators

While list and dictionary comprehensions are concise ways of creating their respective data types, they require that the entire structure be created in memory before being available for use.

    If the amount of data is huge, then it requires a lot of memory.

    If the amount of data is infinite, then their use becomes impossible.

Generators are often used in situations where a lot of data needs to be generated without the overhead of storage of the entire dataset.

    Generators are a special class of functions that simplify the task of writing iterators.

    Any function containing a yield keyword is a generator function.

        On reaching a yield, the generator's state of execution is suspended and local variables are preserved.

        On the next call to the generator's next() method, the function will resume executing.

Here is a simple example of a generator function.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> def generate_odds(upper_limit):
...     for odd in range(1, upper_limit, 2):
...          yield odd
...
>>> odds = generate_odds(5)
>>> print(type(odds))
<class 'generator'>
>>> next(odds)
1
>>> next(odds)
3
>>> next(odds)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
>>> quit()
$

As seen in the output on the previous example; if the next() function is called too many times for a given generator object, a StopIteration exception is raised.

Since a generator acts as an iterator, it can be used with a for loop.

    The benefit of this is that the for loop automatically calls the next() function and silently handles the StopIteration exception.

        This can be seen in the following example.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> def generate_odds(upper_limit):
...     for odd in range(1, upper_limit, 2):
...         yield odd
...
>>> for val in generate_odds(5):
...     print(val, end=" ")
...
1 3
>>> exit()
$

The following example defines a generator to iterate through a given number of days relative to the current date.

generate_dates.py

#!/usr/bin/env python3
import datetime


def following_days(howmany):
    now = datetime.date.today()
    for i in range(1, howmany + 1):
        yield now + datetime.timedelta(days=i)


def main():
    print("Code was run on:", datetime.date.today())
    print("Next 7 days are:")
    for adate in following_days(7):
        print(adate)


if __name__ == "__main__":
    main()

Generator Expressions

Similar to list and dictionary comprehensions, a generator expression is a concise way of creating a generator.

    While list comprehensions use square brackets and dictionary comprehensions use curly braces in their syntax, generator expressions use parentheses ().

The following example rewrites the odd number generator defined previously as a generator expression.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> for x in (odd for odd in range(1, 1000, 2)):
...     print(x, end = "|")
...
1|3|5|7|9|11|13|15|17|19|21|23|25|27|29|31|33|35|37|39|41|43|45|47|49|51|53|55|57|59|61|63|65|67|69|71|73|75|77|79|81|83|85|87|89|91|93|95|97|99|101|103|105|107|109|111|113|115|117|119|121|123|125|127|129|131|133|135|137|139|141|143|145|147|149|151|153|155|157|159|161|163|165|167|169|171|173|175|177|179|181|183|185|187|189|191|193|195|197|199|201|203|205|207|209|211|213|215|217|219|221|223|225|227|229|231|233|235|237|239|241|243|245|247|249|251|253|255|257|259|261|263|265|267|269|271|273|275|277|279|281|283|285|287|289|291|293|295|297|299|301|303|305|307|309|311|313|315|317|319|321|323|325|327|329|331|333|335|337|339|341|343|345|347|349|351|353|355|357|359|361|363|365|367|369|371|373|375|377|379|381|383|385|387|389|391|393|395|397|399|401|403|405|407|409|411|413|415|417|419|421|423|425|427|429|431|433|435|437|439|441|443|445|447|449|451|453|455|457|459|461|463|465|467|469|471|473|475|477|479|481|483|485|487|489|491|493|495|497|499|501|503|505|507|509|511|513|515|517|519|521|523|525|527|529|531|533|535|537|539|541|543|545|547|549|551|553|555|557|559|561|563|565|567|569|571|573|575|577|579|581|583|585|587|589|591|593|595|597|599|601|603|605|607|609|611|613|615|617|619|621|623|625|627|629|631|633|635|637|639|641|643|645|647|649|651|653|655|657|659|661|663|665|667|669|671|673|675|677|679|681|683|685|687|689|691|693|695|697|699|701|703|705|707|709|711|713|715|717|719|721|723|725|727|729|731|733|735|737|739|741|743|745|747|749|751|753|755|757|759|761|763|765|767|769|771|773|775|777|779|781|783|785|787|789|791|793|795|797|799|801|803|805|807|809|811|813|815|817|819|821|823|825|827|829|831|833|835|837|839|841|843|845|847|849|851|853|855|857|859|861|863|865|867|869|871|873|875|877|879|881|883|885|887|889|891|893|895|897|899|901|903|905|907|909|911|913|915|917|919|921|923|925|927|929|931|933|935|937|939|941|943|945|947|949|951|953|955|957|959|961|963|965|967|969|971|973|975|977|979|981|983|985|987|989|991|993|995|997|999|>>>
>>> quit()
$

Processing Parallel Collections

When working with data structures such as lists and tuples, it is common to have multiple structures whose data runs in parallel.

    The built-in zip() constructor can be used to easily create a zip object that can iterate through each of the collections in parallel.

in_parallel.py

#!/usr/bin/env python3
long_names = ["January", "February", "March", "April",
              "May", "June", "July", "August", "September",
              "October", "November", "December"]
abbr_names = ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
              "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
numdays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

fmt = "{:^10} {:^10} {}"
print(fmt.format("#Days:", "Abbr Name:", "Long Name:"))
for days, abbr, lng in zip(numdays, abbr_names, long_names):
    print(fmt.format(days, abbr, lng))

    If the iterable objects passed to the zip() constructor are not all the same size, the shortest argument dictates the number of times the zip object can be iterated over.

Specialized Sorts

Several examples throughout the course have shown the use of the sort() method of a list and the top level sorted() function.

    Sorting a sequence such as a list or a tuple first compares the first two items, and if they differ this determines the outcome of the comparison.

        If they are equal, the next two items are compared, and so on, until either sequence is exhausted.

    This n-ary level of sorting is demonstrated in the tertiary sort of the two-dimensional list shown below.

$ python3
Python 3.9.10 (main, Feb 9 2022, 00:00:00)
[GCC 11.2.1 20220127 (Red Hat 11.2.1-9)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> thelist = [[1,1,7], [1,1,1], [1,2,3], [1,2,1], [2,1,1], [1,2,2]]
>>> thelist.sort()
>>> print(thelist)
[[1, 1, 1], [1, 1, 7], [1, 2, 1], [1, 2, 2], [1, 2, 3], [2, 1,
1]]
>>> quit()
$

The ability of a sequence to be sorted to any level provides additional capabilities when calling the sort() method and sorted() function with the key parameter.

    The following example demonstrates a tertiary sort of customer's information.

        The primary sort will be by state.

        If the states match, the secondary sort will be by last name.

        If the last names match, the tertiary sort will be by first name.

    This is accomplished by defining a lambda function that takes a list of strings pertaining to the customer and returns a tuple of the state, last name and first name.

    The application reuses the get_customers() function from the customer_functions module defined earlier in the chapter.

tertiary_sort.py

#!/usr/bin/env python3
from customer_functions import get_customers


def main():
    customer_list = get_customers()
    customer_list.sort(key=lambda x: (x[4], x[1], x[0]))
    for customer in customer_list:
        print(customer)


if __name__ == "__main__":
    main()

The execution output of the preceding program might be as follows:

$ python3 tertiary_sort.py
['Christopher', 'Smith', '1918 Mercersburg Rd', 'Juneau', 'AK', '99801']
['Alicia', 'Reed', '34 Southern Blvd', 'Tucson', 'AZ', '71801']
['Brian', 'Reed', '134 Adams St', 'Ashdown', 'AZ', '71822']
['Christine', 'Scott', '1807 W Pike St Ste B', 'Hope', 'AZ', '71801']
['Cynthia', 'Stewart', '212 Laurel St', 'Prescott', 'AZ', '71857']
['Jennifer', 'Turner', '746 Saint Andrews Blvd', 'Texarkana', 'AZ', '71854']
['Jessica', 'Collins', '300 E 1st N', 'Burlington', 'CO', '80807']
['Donald', 'Garcia', '330 Boise St', 'Defuniak Springs', 'FL', '32435']
['Dennis', 'Edwards', '306 Hwy 59 N.', 'Mecca', 'IN', '47860']
['Donna', 'Gonzalez', '3375 Koapaka St Suite 250', 'Clinton', 'IN', '47842']
['Douglas', 'Hall', '400 Se Lincoln Rd', 'Bloomington', 'IN', '47404']
['Edward', 'Harris', '406 S Jackson Ave', 'Fowler', 'IN', '47944']
['Angela', 'Mitchell', '119 W Court St', 'Veedersburg', 'IN', '47987']
...
$

    The second and third lines of the preceding output show how the customers were sorted by their first names because the state and last name were the same for both entries.

A more object-oriented approach to the previous examples dealing with the customers.txt file, would be to start by defining classes to represent the data as an Address class and a Customer class to represent all the data as objects.

    These two data types are defined in the following module.

customer_and_address.py

#!/usr/bin/env python3
class Address:
    def __init__(self, street, city, state, zip):
        self.street = street
        self.city = city
        self.state = state
        self.zip = zip

    def __str__(self):
        return "".join([self.street, "\n", self.city, ", ", self.state, " ",
                       self.zip])


class Customer:
    def __init__(self, first_name, last_name, address):
        self.first_name = first_name
        self.last_name = last_name
        self.address = address

    def __str__(self):
        return "".join([self.first_name, " ", self.last_name, "\n",
                       str(self.address)])

The following application reads the customers.txt file into a list of Customer objects by using the two data types defined previously.

    The list is then sorted similarly to the previous tertiary sort.

tertiary_sort2.py

#!/usr/bin/env python3
from customer_and_address import Address, Customer


def get_customers():
    customer_list = []
    with open("customers.txt", "r") as thefile:
        for customer_txt in thefile:
            c = customer_txt.rstrip().split(",")
            address = Address(c[2], c[3], c[4], c[5])
            customer = Customer(c[0], c[1], address)
            customer_list.append(customer)
    return customer_list


def sortby(customer):
    return (customer.address.state, customer.last_name, customer.first_name)


def main():
    customer_list = get_customers()
    customer_list.sort(key=sortby)
    for customer in customer_list:
        print(customer, end="\n\n")


if __name__ == "__main__":
    main()

The execution output of the preceding program might be as follows:

$ python3 tertiary_sort2.py
Christopher Smith
1918 Mercersburg Rd
Juneau, AK 99801

Alicia Reed
34 Southern Blvd
Tucson, AZ 71801

Brian Reed
134 Adams St
Ashdown, AZ 71822

Christine Scott
1807 W Pike St Ste B
Hope, AZ 71801
$

Python provides the operator module as part of the standard library that contains convenience functions to make it easier and faster to do both basic and specialized sorts.

    The operator module has an itemgetter() function and an attrgetter() function that can be used as the value of the key parameter to both the sort() method of a list and the sorted() function.

        The following example uses the operator.itemgetter() and operator.attrgetter() functions to sort customers.

items_and_attributes.py

#!/usr/bin/env python3
from operator import itemgetter, attrgetter
from customer_functions import get_customers as getlist01
from tertiary_sort2 import get_customers as getlist02


def main():
    nestedlist = getlist01()
    # get items 4, 1 and 0 as the sort keys from the list
    nestedlist.sort(key=itemgetter(4, 1, 0))
    for alist in nestedlist[:3]:
        print(alist)
    print()
    customerlist = getlist02()
    # get the address.state, last_name, and first_name
    # attributes from each Customer object being sorted
    customerlist.sort(key=attrgetter('address.state', 'last_name',
                                     'first_name'))
    for customer in customerlist[:3]:
        print(customer, end=2*"\n")


if __name__ == "__main__":
    main()

The execution output of the preceding example might be as follows:

$ python3 items_and_attributes.py
['Christopher', 'Smith', '1918 Mercersburg Rd', 'Juneau', 'AK','99801']
['Alicia', 'Reed', '34 Southern Blvd', 'Tucson', 'AZ', '71801']
['Brian', 'Reed', '134 Adams St', 'Ashdown', 'AZ', '71822']

Christopher Smith
1918 Mercersburg Rd
Juneau, AK 99801

Alicia Reed
34 Southern Blvd
Tucson, AZ 71801

Brian Reed
134 Adams St
Ashdown, AZ 71822
$

Exercises

The solution files for these exercises are in the AD141-apps repository, within the data_structures/solutions directory.
Exercise 1

Write list comprehensions to produce the following lists:

    A list of elements 0,1,2,3,4,â€¦,99

    A list from the preceding comprehension of those values that are evenly divisible by 5.

Exercise 2

Write a list comprehension to create a list of tuples, of x and the factorial of x, for the numbers from 5 to 10 inclusive.

    The math module has a factorial() function that can be used.

Exercise 3

Write a dictionary comprehension that generates a dictionary of numbers and their factorials in the range (1,10).

    Using that dictionary, multiply 6 factorial times 5 factorial.

Exercise 4

Suppose there is a file with three values per line.

    The values are white space separated as follows.

        OwnerName ComputerType ComputerValue 

    Read the lines and make a dictionary of dictionaries so the keys are the owner and the values are a dictionary consisting of the computer type as the key and the computer value as the value.

    Finally, print the dictionary.

    The dataset might look as follows:

Joe Desktop 500
Joe Laptop 200
Joe Desktop 400
Mary Desktop 200
Mary Laptop 800
Beth Laptop 500
Beth Tablet 250
Joe Tablet 250

    The output might look as follows:

{
'Mary': {'Desktop': 200, 'Laptop': 800},
'Beth': {'Tablet': 250, 'Laptop': 500},
'Joe': {'Desktop': 900, 'Tablet': 250, 'Laptop': 200}
}